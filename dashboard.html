<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spotify Dashboard</title>

  <style>
      --bg-primary: #121212;
      --bg-secondary: #181818;
      --bg-tertiary: #282828;
    }
  </style>

  
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    html {
      scroll-behavior: smooth;
    }
    
  
    :root {
      --bg-primary: #121212;
      --bg-secondary: #181818;
      --bg-tertiary: #282828;
      --text-primary: #fff;
      --text-secondary: #b3b3b3;
      --accent: #1db954;
      --border: #282828;
      --shadow: rgba(0, 0, 0, 0.5);
      --card-bg: rgba(0, 0, 0, 0.15);
    }
    
    body.light-mode {
      --bg-primary: #ffffff;
      --bg-secondary: #f5f5f5;
      --bg-tertiary: #e0e0e0;
      --text-primary: #000000;
      --text-secondary: #666666;
      --accent: #1db954;
      --border: #e0e0e0;
      --shadow: rgba(0, 0, 0, 0.1);
      --card-bg: rgba(0, 0, 0, 0.03);
    }
    
    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      padding-top: 60px;
      transition: background 0.3s ease, color 0.3s ease;
    }
    
    
    .animate-on-scroll {
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.6s ease, transform 0.6s ease;
    }
    
    .animate-on-scroll.animate-in {
      opacity: 1;
      transform: translateY(0);
    }
    
    
    #main-nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--bg-primary);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      padding: 12px 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      overflow-x: auto;
      box-shadow: 0 2px 20px var(--shadow);
      transition: background 0.3s ease, border-color 0.3s ease;
    }
    #main-nav::-webkit-scrollbar {
      height: 4px;
    }
    #main-nav::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 4px;
    }
    #main-nav .nav-brand {
      font-family: Monument, sans-serif;
      font-size: 16px;
      font-weight: 900;
      color: var(--accent);
      white-space: nowrap;
      margin-right: 20px;
      cursor: pointer;
      transition: opacity 0.3s ease;
    }
    #main-nav .nav-brand:hover {
      opacity: 0.8;
    }
    #main-nav .nav-links {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: nowrap;
    }
    #main-nav a {
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 13px;
      font-weight: 500;
      padding: 6px 12px;
      border-radius: 20px;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    #main-nav a:hover {
      color: var(--text-primary);
      background: rgba(29, 185, 84, 0.1);
    }
    #main-nav a.active {
      color: #000;
      background: var(--accent);
      font-weight: 600;
    }
    
    
    #burger-menu {
      display: none;
      flex-direction: column;
      gap: 4px;
      width: 28px;
      height: 24px;
      cursor: pointer;
      padding: 4px;
      background: transparent;
      border: none;
      z-index: 1001;
    }
    #burger-menu span {
      width: 100%;
      height: 3px;
      background: var(--text-primary);
      border-radius: 2px;
      transition: all 0.3s ease;
      transform-origin: center;
    }
    #burger-menu.active span:nth-child(1) {
      transform: translateY(7px) rotate(45deg);
    }
    #burger-menu.active span:nth-child(2) {
      opacity: 0;
    }
    #burger-menu.active span:nth-child(3) {
      transform: translateY(-7px) rotate(-45deg);
    }
    
   
    #mobile-menu {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      padding: 20px;
      gap: 4px;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index: 999;
      overflow-y: auto;
      box-shadow: 0 4px 20px var(--shadow);
    }
    #mobile-menu.active {
      transform: translateX(0);
    }
    #mobile-menu a {
      color: var(--text-primary);
      text-decoration: none;
      font-size: 16px;
      font-weight: 500;
      padding: 14px 16px;
      border-radius: 8px;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }
    #mobile-menu a:hover, #mobile-menu a.active {
      background: rgba(29, 185, 84, 0.1);
      border-color: var(--accent);
      color: var(--accent);
    }
    
    
    @media (max-width: 768px) {
      #main-nav {
        padding: 10px 16px;
      }
      #main-nav .nav-links {
        display: none;
      }
      #burger-menu {
        display: flex;
      }
      #back-to-top {
        width: 44px;
        height: 44px;
        bottom: 20px;
        right: 20px;
      }
    }
    
    
    #theme-toggle {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 6px 14px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s ease;
      flex-shrink: 0;
      letter-spacing: 0.3px;
    }
    #theme-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    #theme-toggle svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }
    
    
    #back-to-top {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 48px;
      height: 48px;
      background: var(--accent);
      border: none;
      border-radius: 50%;
      color: #000;
      font-size: 20px;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(29, 185, 84, 0.4);
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
      z-index: 10001;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #back-to-top.visible {
      opacity: 1;
      transform: translateY(0);
    }
    #back-to-top.player-visible {
      bottom: 110px;
    }
    #back-to-top:hover {
      background: #1ed760;
      transform: translateY(-4px);
      box-shadow: 0 6px 28px rgba(29, 185, 84, 0.6);
    }
    
    .swipe-container {
      display: grid;
      grid-template-columns: 1fr 560px;
      gap: 40px;
      align-items: start;
    }
    .swipe-area {
      position: relative;
      min-height: 480px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .swipe-deck {
      position: relative;
      width: 100%;
      max-width: 320px;
      height: 440px;
      margin-bottom: 24px;
    }
    .swipe-card {
      position: absolute;
      width: 100%;
      height: 100%;
      background: var(--bg-secondary);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      cursor: grab;
      transition: transform 0.1s ease, box-shadow 0.3s ease;
      user-select: none;
    }
    .swipe-card:active {
      cursor: grabbing;
    }
    .swipe-card.dragging {
      transition: none;
    }
    .swipe-card.swiped-left {
      animation: swipeLeft 0.5s ease-out forwards;
    }
    .swipe-card.swiped-right {
      animation: swipeRight 0.5s ease-out forwards;
    }
    @keyframes swipeLeft {
      to {
        transform: translateX(-150%) rotate(-30deg);
        opacity: 0;
      }
    }
    @keyframes swipeRight {
      to {
        transform: translateX(150%) rotate(30deg);
        opacity: 0;
      }
    }
    .swipe-card-image {
      width: 100%;
      height: 320px;
      object-fit: cover;
      background: linear-gradient(135deg, #1db954 0%, #191414 100%);
    }
    .swipe-card-info {
      padding: 18px;
      background: var(--bg-secondary);
    }
    .swipe-card-title {
      font-size: 20px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 6px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .swipe-card-artist {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 10px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .swipe-card-badges {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .badge {
      display: inline-block;
      padding: 3px 10px;
      background: rgba(29, 185, 84, 0.15);
      color: var(--accent);
      border-radius: 10px;
      font-size: 11px;
      font-weight: 600;
    }
    .swipe-buttons {
      display: flex;
      gap: 24px;
      justify-content: center;
    }
    .swipe-action-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 2px solid;
      background: var(--bg-secondary);
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .swipe-action-btn.dislike {
      border-color: #ff4458;
      color: #ff4458;
    }
    .swipe-action-btn.dislike:hover {
      background: #ff4458;
      color: #fff;
      transform: scale(1.1);
      box-shadow: 0 8px 24px rgba(255, 68, 88, 0.4);
    }
    .swipe-action-btn.like {
      border-color: #1db954;
      color: #1db954;
    }
    .swipe-action-btn.like:hover {
      background: #1db954;
      color: #fff;
      transform: scale(1.1);
      box-shadow: 0 8px 24px rgba(29, 185, 84, 0.4);
    }
    .swipe-end {
      text-align: center;
      padding: 40px;
    }
    .btn-primary {
      padding: 12px 24px;
      background: var(--accent);
      color: #000;
      border: none;
      border-radius: 24px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .btn-primary:hover:not(:disabled) {
      background: #1ed760;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(29, 185, 84, 0.4);
    }
    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .stats-panel {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 16px;
      position: sticky;
      top: 80px;
      align-content: start;
    }
    .stat-card {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .stat-card canvas {
      width: 100% !important;
      height: 240px !important;
    }
    
    :root.light .stat-card h3,
    :root.light .stat-card .stat-label,
    :root.light .stat-card .stat-value,
    :root.light .liked-item {
      color: #000 !important;
    }
    :root.light #genre-pie-chart,
    :root.light #mood-radar-chart {
      filter: brightness(0.95) contrast(1.05);
    }
    .stat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
    }
    .stat-item:last-child {
      border-bottom: none;
    }
    .stat-label {
      color: var(--text-secondary);
      font-size: 14px;
    }
    .stat-value {
      color: var(--accent);
      font-size: 24px;
      font-weight: 700;
    }
    .liked-list {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 16px;
    }
    .liked-item {
      padding: 8px 0;
      color: var(--text-secondary);
      font-size: 13px;
      border-bottom: 1px solid var(--border);
    }
    .liked-item:last-child {
      border-bottom: none;
    }
    
    @media (max-width: 968px) {
      .swipe-container {
        grid-template-columns: 1fr;
      }
      .stats-panel {
        position: static;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        display: grid;
      }
    }
    @media (max-width: 480px) {
      .swipe-deck {
        max-width: 100%;
        height: 420px;
      }
      .swipe-card-image {
        height: 300px;
      }
      .swipe-action-btn {
        width: 55px;
        height: 55px;
      }
      .stats-panel {
        grid-template-columns: 1fr;
      }
    }
    
    .main-content {
      padding: 20px;
    }
    input#search {
      width: 100%;
      padding: 12px;
      margin: 20px 0;
      border-radius: 8px;
      border: none;
      font-size: 16px;
      background: #1b1b1b;
      color: #fff;
      box-sizing: border-box;
    }
    #songs-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      grid-auto-rows: 120px;
      gap: 8px;
      padding: 0 10px;
    }
    .song-card {
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      opacity: 0;
      transform: scale(0.9);
    }
    .song-card.visible {
      opacity: 1;
      transform: scale(1);
    }
   
    .song-card:nth-child(3n+1) {
      grid-column: span 2;
      grid-row: span 2;
    }
    .song-card:nth-child(7n+2) {
      grid-column: span 2;
      grid-row: span 1;
    }
    .song-card:nth-child(11n+4) {
      grid-column: span 1;
      grid-row: span 2;
    }
    .song-card:nth-child(13n+6) {
      grid-column: span 2;
      grid-row: span 2;
    }
    .song-card:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(29, 185, 84, 0.4);
      z-index: 10;
    }
    .song-card img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .song-info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
      padding: 12px 8px 8px;
      opacity: 0;
      transition: opacity 0.3s ease;
      text-align: left;
    }
    .song-card:hover .song-info {
      opacity: 1;
    }
    .song-info .title {
      font-weight: 700;
      font-size: 13px;
      color: #1db954;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .song-info .artist {
      font-size: 11px;
      color: #b3b3b3;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .song-info .streams {
      font-size: 10px;
      color: #888;
      margin-top: 2px;
    }
    
   
    @media (max-width: 768px) {
      #songs-container {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        grid-auto-rows: 100px;
        gap: 6px;
        padding: 0 5px;
      }
      .song-info .title {
        font-size: 11px;
      }
      .song-info .artist {
        font-size: 10px;
      }
      .song-info .streams {
        font-size: 9px;
      }
      input#search {
        font-size: 14px;
        padding: 10px;
      }
    }
    
    @media (max-width: 480px) {
      #songs-container {
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        grid-auto-rows: 80px;
        gap: 5px;
      }
    }
   

    .visualization-container {
      position: relative;
      height: 600px;
      margin: 40px auto;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 20px;
      overflow: hidden;
    }

    #genre3DCanvas {
      width: 100%;
      height: 100%;
    }

    .genre-info {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      text-align: center;
      width: 100%;
    }

    .genre-title {
      font-family: 'Monument Extended', sans-serif;
      font-size: 32px;
      margin-bottom: 25px;
      color: #ffffff;
      font-weight: 400;
      letter-spacing: 3px;
      text-transform: uppercase;
      position: relative;
      display: inline-block;
      padding-bottom: 15px;
      mix-blend-mode: difference;
    }

    .genre-title::before,
    .genre-title::after {
      content: '';
      position: absolute;
      bottom: 0;
      height: 2px;
      background: #1db954;
    }

    .genre-title::before {
      left: 0;
      width: 100%;
      background: rgba(29,185,84,0.3);
    }

    .genre-title::after {
      left: 0;
      width: 35%;
      background: #1db954;
      animation: titleLine 2s infinite;
    }

    @keyframes titleLine {
      0% { transform: translateX(0); }
      50% { transform: translateX(186%); }
      100% { transform: translateX(0); }
    }

    .genre-details {
      font-size: 16px;
      opacity: 0.8;
    }

    .genre-tooltip {
      position: absolute;
      background: rgba(29, 185, 84, 0.9);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      pointer-events: none;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s ease;
      font-size: 14px;
      z-index: 100;
      backdrop-filter: blur(5px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

   
  .chart2-tooltip { transition: all 0.12s ease; }
  
  .chart2-tooltip {
    background: linear-gradient(135deg, rgba(29,185,84,0.95), rgba(14,220,120,0.95));
    color: #04120a;
    padding: 10px 14px;
    border-radius: 10px;
    font-weight: 600;
    box-shadow: 0 12px 40px rgba(2, 50, 20, 0.45);
    transform-origin: left top;
  }

 
  .chart2-label {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 12px;
    color: #e6f7ec;
    text-shadow: 0 2px 6px rgba(0,0,0,0.6);
    pointer-events: none;
    white-space: nowrap;
    transform: translate(-50%, -50%);
  }

  
  #artists3d-container:active {
    cursor: grabbing;
  }

  
  #mood-container:active {
    cursor: grabbing;
  }
  #mood-select,
  .mood-select-dropdown {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-color: rgba(18,18,18,0.95);
    background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1.5 1.5L6 6L10.5 1.5' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    padding-right: 38px;
  }
  #mood-select:hover,
  .mood-select-dropdown:hover {
    border-color: rgba(29,185,84,0.5);
    background-color: rgba(18,18,18,1);
    background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1.5 1.5L6 6L10.5 1.5' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  }
  #mood-select:focus,
  .mood-select-dropdown:focus {
    border-color: #1db954;
    box-shadow: 0 0 0 2px rgba(29,185,84,0.2);
    background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1.5 1.5L6 6L10.5 1.5' stroke='%23ffffff' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  }

  /* Light mode: arrow becomes black */
  body.light-mode #mood-select,
  body.light-mode .mood-select-dropdown {
    background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1.5 1.5L6 6L10.5 1.5' stroke='%23000000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  }
  body.light-mode #mood-select:hover,
  body.light-mode .mood-select-dropdown:hover {
    background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1.5 1.5L6 6L10.5 1.5' stroke='%23000000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  }
  body.light-mode #mood-select:focus,
  body.light-mode .mood-select-dropdown:focus {
    background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1.5 1.5L6 6L10.5 1.5' stroke='%23000000' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  }
  /* Keep the custom white down-arrow on the select like other charts */
    
    /* Modal styles */
    #song-modal {
      position: fixed;
      inset: 0;
      display: none; /* shown via JS */
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.6);
      z-index: 9999;
      padding: 20px;
    }

    #song-modal .modal-inner {
      position: relative;
      background: linear-gradient(180deg, #0f0f0f, #121212);
      border-radius: 14px;
      padding: 20px;
      max-width: 480px;
      width: 100%;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    #song-modal .modal-inner img {
      width: 100%;
      max-height: 320px;
      object-fit: cover;
      border-radius: 10px;
    }

    #close-modal {
      position: absolute;
      top: 10px;
      right: 14px;
      font-size: 26px;
      color: #fff;
      cursor: pointer;
      line-height: 1;
    }

    /* Mini audio controller */
    #audio-player {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, #181818, #0f0f0f);
      border-top: 2px solid rgba(29,185,84,0.3);
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      z-index: 10000;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.6);
      transform: translateY(100%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    #audio-player.visible {
      transform: translateY(0);
    }
    #audio-player .track-info {
      flex: 1;
      min-width: 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #audio-player .track-cover {
      width: 48px;
      height: 48px;
      border-radius: 6px;
      object-fit: cover;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }
    #audio-player .track-meta {
      flex: 1;
      min-width: 0;
    }
    #audio-player .track-title {
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #audio-player .track-artist {
      font-size: 12px;
      color: #b3b3b3;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #audio-player .controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #audio-player button {
      background: none;
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      padding: 6px;
      border-radius: 50%;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
    }
    #audio-player button:hover {
      background: rgba(29,185,84,0.2);
      transform: scale(1.1);
    }
    #audio-player button.active {
      color: #1db954;
    }
    #audio-player .bpm-badge {
      background: rgba(29,185,84,0.15);
      color: #1db954;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }
    #audio-player .bpm-badge:hover {
      background: rgba(29,185,84,0.3);
    }
    #audio-player .progress-bar {
      flex: 1;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      cursor: pointer;
      position: relative;
      min-width: 120px;
    }
    #audio-player .progress-fill {
      height: 100%;
      background: #1db954;
      border-radius: 2px;
      width: 0%;
      transition: width 0.1s linear;
      position: relative;
    }
    #audio-player .progress-fill::after {
      content: '';
      position: absolute;
      right: -6px;
      top: 50%;
      transform: translateY(-50%);
      width: 12px;
      height: 12px;
      background: #1db954;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s;
    }
    #audio-player .progress-bar:hover .progress-fill::after {
      opacity: 1;
    }
    #audio-player .time {
      font-size: 11px;
      color: #b3b3b3;
      min-width: 80px;
      text-align: center;
    }
    #audio-player .volume-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #audio-player .volume-slider {
      width: 80px;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      outline: none;
    }
    #audio-player .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: #1db954;
      border-radius: 50%;
      cursor: pointer;
    }
    #audio-player .volume-slider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #1db954;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

  </style>
</head>
<body>

<!-- Sticky Navigation -->
<nav id="main-nav">
  <a href="index.html" class="nav-brand" style="text-decoration:none;color:inherit;">SPOTIFY STATS</a>
  <button id="burger-menu" aria-label="Menu">
    <span></span>
    <span></span>
    <span></span>
  </button>
  <div class="nav-links">
    <a href="#radial">Top Hits</a>
  <a href="#radar">Radar</a>
    <a href="#top-artists">Top Artists</a>
    <a href="#mood">Mood</a>
    <a href="#higher-or-lower">Plus ou Moins</a>
    <a href="#timeline">Timeline</a>
    <a href="#genres">Genres</a>
    <a href="#swipe-playlist">Swipe Playlist</a>
    <a href="#search-section">Recherche</a>
  </div>
  <button id="theme-toggle" title="Changer de th√®me">
    <svg viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
    <span>Sombre</span>
  </button>
</nav>

<!-- Mobile Menu -->
<div id="mobile-menu">
  <a href="#radial">Top Hits</a>
  <a href="#radar">Radar</a>
  <a href="#top-artists">Top Artists</a>
  <a href="#mood">Mood</a>
  <a href="#higher-or-lower">Plus ou Moins</a>
  <a href="#timeline">Timeline</a>
  <a href="#genres">Genres</a>
  <a href="#swipe-playlist">Swipe Playlist</a>
  <a href="#search-section">Recherche</a>
</div>

<!-- Back to Top Button -->
<button id="back-to-top" title="Retour en haut">‚Üë</button>

<div class="main-content">

<!-- Radial 3D chart (Top songs) -->
<div id="radial" class="animate-on-scroll" style="max-width:900px;margin:80px auto 40px;">
  <h3 style="color:var(--text-primary);text-align:center;font-family:Monument, sans-serif;margin-bottom:20px;text-transform:uppercase;font-size:24px;">TOP 12 ‚Äî CHANSONS LES PLUS √âCOUT√âES</h3>
  <p style="color:var(--text-secondary);text-align:center;margin:6px auto 0;font-size:14px;max-width:640px;pointer-events:none;line-height:1.3;padding-bottom:4px;">Survolez une colonne pour voir le titre, l'artiste et le nombre de streams.</p>
  <div class="radial-wrap" style="position:relative;height:520px;background:transparent;border-radius:12px;padding-top:32px;">
    <canvas id="chart2" style="width:100%;height:100%;display:block;border-radius:12px;"></canvas>
    <div class="chart2-tooltip" style="position:fixed;opacity:0;pointer-events:none;z-index:2000;background:rgba(0,0,0,0.85);color:#fff;padding:8px 10px;border-radius:6px;font-size:13px;box-shadow:0 8px 24px rgba(0,0,0,0.5);"></div>
  </div>
</div>

<!-- Radar: audio features -->
<div id="radar" class="animate-on-scroll" style="max-width:900px;margin:60px auto 60px;">
  <h3 style="color:var(--text-primary);text-align:center;font-family:Monument, sans-serif;margin-bottom:12px;text-transform:uppercase;font-size:24px;">Profil audio ‚Äî Radar</h3>
    <p style="color:var(--text-secondary);text-align:center;margin:0 auto 12px auto;font-size:13px;max-width:640px;">Visualisez les caract√©ristiques audio moyennes d'un titre (√©nergie, valence, etc.).</p>
  <div style="display:flex;gap:10px;justify-content:center;align-items:center;margin-bottom:12px;flex-wrap:wrap;">
    <label for="radar-select" style="color:var(--text-secondary);font-size:13px;">Titre :</label>
    <select id="radar-select" style="background:var(--bg-secondary);color:var(--text-primary);border:1px solid var(--border);border-radius:10px;padding:8px 12px;min-width:280px;">
      <option>Chargement‚Ä¶</option>
    </select>
  </div>
  <div style="position:relative;background:rgba(0,0,0,0.15);border-radius:14px;padding:16px;">
    <canvas id="radarChart" style="width:100%;max-height:460px;"></canvas>
  </div>
</div>


<!-- Top Artists 3D Section -->
<div id="top-artists" class="animate-on-scroll" style="max-width:900px;margin:60px auto 60px;">
  <h3 style="color:var(--text-primary);text-align:center;font-family:Monument, sans-serif;margin-bottom:12px;text-transform:uppercase;font-size:24px;">Top Artistes</h3>
    <p style="color:var(--text-secondary);text-align:center;margin:0 auto 12px auto;font-size:13px;max-width:640px;">Classement des artistes les plus pr√©sents dans le top Spotify.</p>
  <div style="position:relative;background:var(--card-bg);border:1px solid var(--border);border-radius:14px;overflow:hidden;">
  <div id="artists3d-container" style="width:100%;height:500px;cursor:grab;position:relative;"></div>
    <div id="artists3d-tooltip" style="position:absolute;top:10px;left:10px;background:rgba(0,0,0,0.9);color:#fff;padding:12px 16px;border-radius:10px;pointer-events:none;opacity:0;transition:opacity 0.2s;font-size:12px;max-width:260px;border:1px solid rgba(29,185,84,0.3);"></div>
  </div>
</div>

<!-- Mood Explorer Section -->
<div id="mood" class="animate-on-scroll" style="max-width:900px;margin:60px auto 60px;">
  <h3 style="color:var(--text-primary);text-align:center;font-family:Monument, sans-serif;margin-bottom:12px;text-transform:uppercase;font-size:24px;">Mood Explorer</h3>
    <p style="color:var(--text-secondary);text-align:center;margin:0 auto 12px auto;font-size:13px;max-width:640px;">Explorez les chansons selon leur ambiance (joyeux, triste, √©nergique, calme).</p>
  
  <!-- Filter above the chart -->
  <div style="display:flex;justify-content:flex-end;align-items:center;margin-bottom:12px;gap:10px;">
    <label for="mood-select" style="color:var(--text-secondary);font-size:12px;font-weight:500;">Filtrer par mood :</label>
  <select id="mood-select" style="background-color:var(--bg-secondary);color:var(--text-primary);border:1px solid var(--border);border-radius:6px;padding:4px 28px 4px 8px;font-size:12px;outline:none;cursor:pointer;">
  <option value="">Toutes les chansons</option>
      <option value="joyeuxEnergetique">Joyeux & √ânergique</option>
      <option value="joyeuxCalme">Joyeux & Calme</option>
      <option value="tristeEnergetique">Triste & √ânergique</option>
      <option value="tristeCalme">Triste & Calme</option>
    </select>
  </div>
  
  <div style="position:relative;background:rgba(0,0,0,0.15);border-radius:14px;overflow:hidden;">
    <div id="mood-container" style="width:100%;height:550px;cursor:grab;position:relative;"></div>
    <div id="mood-tooltip" style="position:absolute;top:10px;left:10px;background:rgba(0,0,0,0.9);color:#fff;padding:12px 16px;border-radius:10px;pointer-events:none;opacity:0;transition:opacity 0.2s;font-size:12px;max-width:260px;border:1px solid rgba(29,185,84,0.3);z-index:10;"></div>
  </div>
</div>

<!-- Higher or Lower Game Section -->
<div id="higher-or-lower" class="animate-on-scroll" style="max-width:600px;margin:30px auto;padding:0 20px;">
  
  <!-- Header -->
  <div style="text-align:center;margin-bottom:20px;">
    <h3 style="color:var(--text-primary);text-align:center;font-family:Monument, sans-serif;margin-bottom:12px;text-transform:uppercase;font-size:24px;">Plus ou Moins</h3>
    <p style="color:var(--text-secondary);font-size:11px;margin:0;font-weight:400;">Comparez les streams entre deux chansons</p>
  </div>
  
  <!-- Game Container -->
  <div style="background:var(--bg-primary);border:1px solid var(--border);border-radius:6px;padding:20px 16px;box-shadow:0 4px 60px var(--shadow);">
    
    <div id="game-container" style="position:relative;">
      
      <!-- Stats Bar -->
      <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:20px;">
        <div style="text-align:center;">
          <div style="font-size:8px;color:var(--text-secondary);font-weight:500;margin-bottom:3px;text-transform:uppercase;letter-spacing:0.5px;">Score</div>
          <div id="game-score" style="font-size:20px;color:var(--accent);font-weight:600;">0</div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:8px;color:var(--text-secondary);font-weight:500;margin-bottom:3px;text-transform:uppercase;letter-spacing:0.5px;">S√©rie</div>
          <div id="game-streak" style="font-size:20px;color:var(--text-primary);font-weight:600;">0</div>
        </div>
        <div style="text-align:center;">
          <div style="font-size:8px;color:var(--text-secondary);font-weight:500;margin-bottom:3px;text-transform:uppercase;letter-spacing:0.5px;">Record</div>
          <div id="game-best" style="font-size:20px;color:var(--text-primary);font-weight:600;">0</div>
        </div>
      </div>

      <!-- Cards Container -->
      <div style="display:grid;grid-template-columns:1fr auto 1fr;gap:12px;align-items:stretch;">
        
        <!-- Left Card -->
        <div id="left-card" style="background:var(--bg-secondary);border:1px solid var(--border);border-radius:5px;padding:10px;transition:all 0.3s ease;">
          <div style="position:relative;width:100%;aspect-ratio:1;margin-bottom:8px;overflow:hidden;border-radius:3px;">
            <img id="left-cover" style="width:100%;height:100%;object-fit:cover;">
          </div>
          <div>
            <div id="left-title" style="font-size:11px;font-weight:600;color:var(--text-primary);margin-bottom:2px;line-height:1.3;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;line-clamp:2;-webkit-box-orient:vertical;"></div>
            <div id="left-artist" style="font-size:9px;color:var(--text-secondary);margin-bottom:7px;font-weight:400;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></div>
            <div style="background:var(--bg-tertiary);padding:7px;border-radius:4px;">
              <div style="font-size:7px;color:var(--text-secondary);margin-bottom:2px;font-weight:500;text-transform:uppercase;letter-spacing:0.5px;">Streams</div>
              <div id="left-streams" style="font-size:12px;font-weight:600;color:var(--accent);"></div>
            </div>
          </div>
        </div>

        <!-- VS Divider -->
        <div style="display:flex;align-items:center;justify-content:center;width:20px;">
          <div style="font-size:9px;font-weight:600;color:var(--text-secondary);letter-spacing:1px;">VS</div>
        </div>

        <!-- Right Card & Buttons -->
        <div style="display:flex;flex-direction:column;gap:10px;">
          <div id="right-card" style="background:var(--bg-secondary);border:1px solid var(--border);border-radius:5px;padding:10px;transition:all 0.3s ease;flex:1;">
            <div style="position:relative;width:100%;aspect-ratio:1;margin-bottom:8px;overflow:hidden;border-radius:3px;">
              <img id="right-cover" style="width:100%;height:100%;object-fit:cover;">
            </div>
            <div>
              <div id="right-title" style="font-size:11px;font-weight:600;color:var(--text-primary);margin-bottom:2px;line-height:1.3;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;line-clamp:2;-webkit-box-orient:vertical;"></div>
              <div id="right-artist" style="font-size:9px;color:var(--text-secondary);margin-bottom:7px;font-weight:400;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></div>
              <div id="right-mystery" style="background:var(--bg-tertiary);padding:7px;border-radius:4px;">
                <div style="font-size:7px;color:var(--text-secondary);margin-bottom:2px;font-weight:500;text-transform:uppercase;letter-spacing:0.5px;">Streams</div>
                <div style="font-size:20px;font-weight:600;color:var(--text-secondary);">?</div>
              </div>
              <div id="right-revealed" style="background:var(--bg-tertiary);padding:7px;border-radius:4px;display:none;">
                <div style="font-size:7px;color:var(--text-secondary);margin-bottom:2px;font-weight:500;text-transform:uppercase;letter-spacing:0.5px;">Streams</div>
                <div id="right-streams" style="font-size:12px;font-weight:600;color:var(--accent);"></div>
              </div>
            </div>
          </div>
          <!-- Buttons side by side -->
          <div style="display:flex;gap:8px;">
            <button id="btn-higher" style="background:var(--accent);border:none;color:#000;padding:9px 12px;border-radius:16px;font-size:11px;font-weight:600;cursor:pointer;transition:all 0.2s ease;letter-spacing:0.3px;flex:1;">
              Plus √©lev√©
            </button>
            <button id="btn-lower" style="background:var(--bg-tertiary);border:1px solid var(--border);color:var(--text-primary);padding:9px 12px;border-radius:16px;font-size:11px;font-weight:600;cursor:pointer;transition:all 0.2s ease;letter-spacing:0.3px;flex:1;">
              Moins √©lev√©
            </button>
          </div>
        </div>
      </div>

      <!-- Result Message -->
      <div id="result-message" style="margin-top:14px;text-align:center;padding:7px;border-radius:4px;font-size:11px;font-weight:500;opacity:0;transition:all 0.3s ease;"></div>

      <!-- Game Over Screen -->
      <div id="game-over" style="display:none;position:absolute;inset:0;background:#121212;border-radius:6px;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100;">
        <div style="font-size:16px;font-weight:600;color:#fff;margin-bottom:4px;">Partie termin√©e</div>
        <div style="font-size:10px;color:#b3b3b3;margin-bottom:16px;font-weight:400;">Vous avez fait de votre mieux</div>
        <div style="background:#181818;border:1px solid #282828;padding:14px 24px;border-radius:5px;margin-bottom:16px;text-align:center;">
          <div style="font-size:8px;color:#b3b3b3;margin-bottom:4px;font-weight:500;text-transform:uppercase;letter-spacing:0.5px;">Score Final</div>
          <div id="final-score" style="font-size:32px;font-weight:600;color:#1db954;"></div>
        </div>
        <div style="display:flex;gap:8px;">
          <button id="btn-restart" style="background:#1db954;border:none;color:#000;padding:9px 16px;border-radius:16px;font-size:11px;font-weight:600;cursor:pointer;transition:all 0.2s ease;letter-spacing:0.3px;">
            Rejouer
          </button>
          <button id="btn-quit" style="background:#2a2a2a;border:1px solid #3a3a3a;color:#fff;padding:9px 16px;border-radius:16px;font-size:11px;font-weight:600;cursor:pointer;transition:all 0.2s ease;letter-spacing:0.3px;">
            Quitter
          </button>
        </div>
      </div>
    </div>
  </div>
</div>
</div>

<!-- Timeline List -->
<div id="timeline" class="animate-on-scroll" style="max-width:900px;margin:36px auto 26px;">
  <h3 style="color:var(--text-primary);text-align:center;font-family:Monument, sans-serif;margin-bottom:12px;text-transform:uppercase;font-size:24px;">Timeline ‚Äî Sorties</h3>
    <p style="color:var(--text-secondary);text-align:center;margin:0 auto 12px auto;font-size:13px;max-width:640px;">Visualisez la r√©partition des sorties et des √©coutes au fil du temps.</p>
  <div style="display:flex;justify-content:flex-end;align-items:center;margin:0 2px 12px 2px;">
    <div style="display:flex;gap:8px;align-items:center;">
      <select id="timeline-metric" style="background:var(--bg-secondary);color:var(--text-primary);border:1px solid var(--border);border-radius:6px;padding:4px 8px;font-size:12px;outline:none;">
        <option value="streams" selected>Somme des √©coutes</option>
        <option value="count">Nombre de titres</option>
      </select>
    </div>
  </div>
  <div id="timeline-list-wrap" style="max-height:360px;overflow:auto;background:rgba(0,0,0,0.18);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:6px 8px;">
    <div id="timeline-list" style="display:flex;flex-direction:column;gap:6px;"></div>
  </div>
</div>

<div id="genres" class="animate-on-scroll" style="max-width:900px;margin:60px auto 60px;">
    <h3 style="color:var(--text-primary);text-align:center;font-family:Monument, sans-serif;margin-bottom:12px;text-transform:uppercase;font-size:24px;">Genres les plus √©cout√©s</h3>
      <p style="color:var(--text-secondary);text-align:center;margin:0 auto 12px auto;font-size:13px;max-width:640px;">R√©partition des genres musicaux parmi les titres les plus stream√©s.</p>
    <div id="genre3D" class="visualization-container" style="position:relative;">
        <div class="genre-info">
            <div class="genre-details"></div>
        </div>
        <canvas id="genre3DCanvas"></canvas>
        <div class="genre-tooltip"></div>
    </div>
</div>

<!-- Swipe Playlist Section -->
<div id="swipe-playlist" class="animate-on-scroll" style="margin:60px auto;padding:40px 20px;max-width:1200px;">
  <h3 style="color:var(--text-primary);text-align:center;font-family:Monument, sans-serif;margin-bottom:12px;text-transform:uppercase;font-size:24px;">Swipe Playlist</h3>
  <p class="section-subtitle" style="color:var(--text-secondary);text-align:center;margin:0 auto 40px auto;font-size:13px;max-width:640px;">
    Swipez les pochettes pour cr√©er votre playlist personnalis√©e et d√©couvrir vos pr√©f√©rences musicales.
  </p>
  
  <div class="swipe-container">
    <!-- Left: Swipe Cards -->
    <div class="swipe-area">
      <div id="swipe-deck" class="swipe-deck"></div>
      <div class="swipe-buttons">
        <button id="dislike-btn" class="swipe-action-btn dislike" title="Je n'aime pas">
          <span style="font-size:32px;">üëé</span>
        </button>
        <button id="like-btn" class="swipe-action-btn like" title="J'aime">
          <span style="font-size:32px;">‚ù§Ô∏è</span>
        </button>
      </div>
      <div id="swipe-end-message" class="swipe-end" style="display:none;">
        <h3 style="color:var(--accent);margin-bottom:20px;text-transform:uppercase;">Termin√© !</h3>
        <p style="color:var(--text-secondary);margin-bottom:20px;">Vous avez swip√© toutes les chansons disponibles.</p>
        <button id="reset-swipe" class="btn-primary">Recommencer</button>
      </div>
    </div>
    
    <!-- Right: Stats Panel -->
    <div class="stats-panel">
      <div class="stat-card">
        <h3 style="color:var(--accent);font-size:18px;margin-bottom:16px;text-transform:uppercase;">Vos Pr√©f√©rences</h3>
        <div class="stat-item">
          <span class="stat-label">Titres aim√©s</span>
          <span class="stat-value" id="liked-count">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Total swip√©</span>
          <span class="stat-value" id="total-swiped">0</span>
        </div>
      </div>
      
      <div class="stat-card">
        <h3 style="color:var(--accent);font-size:18px;margin-bottom:16px;text-transform:uppercase;">Genres Favoris</h3>
        <canvas id="genre-pie-chart" width="250" height="250"></canvas>
      </div>
      
      <div class="stat-card">
        <h3 style="color:var(--accent);font-size:18px;margin-bottom:16px;text-transform:uppercase;">Profil Musical</h3>
        <canvas id="mood-radar-chart" width="250" height="250"></canvas>
      </div>
      
      <div class="stat-card">
        <h3 style="color:var(--accent);font-size:18px;margin-bottom:16px;text-transform:uppercase;">Ma Playlist</h3>
        <div id="liked-songs-list" class="liked-list"></div>
        <button id="export-playlist" class="btn-primary" disabled>Exporter la Playlist</button>
      </div>
    </div>
  </div>


<div class="animate-on-scroll" style="max-width:320px;margin:180px auto 0 auto;">
  <div style="padding:0;display:flex;flex-direction:column;align-items:center;box-shadow:none;background:none;border-radius:18px;width:100%;overflow:hidden;">
    <img src="afficheGraphiques.png" alt="Affiche Graphiques" style="width:100%;display:block;border-radius:18px;box-shadow:none;">
  </div>

  </div>
</div>
</div>

<div id="search-section" class="animate-on-scroll" style="margin:60px 0;padding:0 20px;">
  <input type="text" id="search" placeholder="Rechercher une chanson ou un artiste" style="background:var(--bg-secondary);color:var(--text-primary);border:1px solid var(--border);">
  <div id="songs-container"></div>
</div>



<div id="song-modal">
  <div class="modal-inner">
    <span id="close-modal">&times;</span>
    <img id="modal-cover" src="" alt="cover">
    <h2 id="modal-title" style="color:#1db954; margin-bottom:10px;"></h2>
    <p id="modal-artist" style="color:#fff; margin-bottom:10px;"></p>
    <p id="modal-streams" style="color:#888;"></p>
  </div>
</div>

<!-- Mini audio player -->
<div id="audio-player">
  <button id="close-player" title="Fermer" style="position:absolute;top:8px;right:8px;background:none;border:none;color:#bfc6b9;font-size:22px;cursor:pointer;z-index:2;">&times;</button>
  <div class="track-info">
    <img class="track-cover" src="https://via.placeholder.com/48" alt="cover" id="player-cover">
    <div class="track-meta">
      <div class="track-title" id="player-title">S√©lectionnez un titre</div>
      <div class="track-artist" id="player-artist">Survolez ou cliquez sur un graphique</div>
    </div>
  </div>
  <div class="controls">
  <button id="play-btn" title="Lecture">‚ñ∂</button>
  </div>
  <div class="progress-bar" id="progress-bar">
    <div class="progress-fill" id="progress-fill"></div>
  </div>
  <div class="time" id="time-display">0:00 / 0:30</div>
  <div class="volume-control">
    <span style="font-size:16px;">üîä</span>
    <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="70">
  </div>
</div>

<script>
const genreByArtist = {
  "Taylor Swift":"Pop","Bad Bunny":"Reggaeton","Peso Pluma":"Latino","Olivia Rodrigo":"Pop",
  "SZA":"R&B","Central Cee":"Rap","Harry Styles":"Pop","NewJeans":"K-pop","Jung Kook":"K-pop",
  "Myke Towers":"Reggaeton","Billie Eilish":"Pop","Feid":"Reggaeton","David Kushner":"Pop",
  "Miley Cyrus":"Pop","Jimin":"K-pop","Latto":"Rap","Quevedo":"Latino"
};

  Papa.parse("Spotify Most Streamed Songs.csv", {
  download:true, header:true, complete:function(results){
    let data = results.data.filter(d=>d.track_name&&d.streams&&d.cover_url&&d.cover_url!=="Not Found");
  data.forEach(song=>{song.audio=`audio/${song.track_name.replace(/\s+/g,"-").toLowerCase()}.mp3`;});
  renderSongs(data); renderRadar(data); renderHeatmap(data); setupSearch(data); initAudioPlayer(data); initHigherOrLower(data); initSwipePlaylist(data);
  initLazy3D(data);
  }
});

window._previewCache = window._previewCache || new Map();
async function getPreviewUrlForSong(song){
  if (!song) return null;
  const key = `${song["artist(s)_name"]||''}|${song.track_name||''}`;
  if (window._previewCache.has(key)) return window._previewCache.get(key);
  const trackName = song.track_name || '';
  const artistName = song['artist(s)_name'] || '';
  const searchTerms = [
    `${artistName} ${trackName}`,
    trackName,
    `${trackName} ${artistName}`,
    trackName.split('(')[0].trim(),
    trackName.split('-')[0].trim(),
    trackName.split('feat')[0].trim()
  ].filter(Boolean);
  for (const term of searchTerms){
    try{
      const url = `https://itunes.apple.com/search?term=${encodeURIComponent(term)}&media=music&entity=song&limit=3&country=US`;
      const res = await fetch(url);
      if (!res.ok) continue;
      const json = await res.json();
      if (json && Array.isArray(json.results) && json.results.length){
        const t10 = (trackName||'').toLowerCase().substring(0,10);
        const exact = json.results.find(r=> (r.trackName||'').toLowerCase().includes(t10) || t10.includes((r.trackName||'').toLowerCase().substring(0,10)) );
        const preview = (exact || json.results[0])?.previewUrl || null;
        if (preview){ window._previewCache.set(key, preview); return preview; }
      }
    }catch(e){ /* ignore and try next */ }
  }
  window._previewCache.set(key, null);
  return null;
}

window._audioElementCache = window._audioElementCache || new Map();
function cacheKeyForSong(song){
  return `${song["artist(s)_name"]||''}|${song.track_name||''}`;
}
async function prewarmAudioForSong(song){
  if (!song) return null;
  const key = cacheKeyForSong(song);
  if (window._audioElementCache.has(key)) return window._audioElementCache.get(key);
  const url = await getPreviewUrlForSong(song);
  if (!url) return null;
  const a = new Audio();
  a.src = url;
  a.preload = 'auto';
  a.crossOrigin = 'anonymous';
  a.volume = 0.5;
  try { a.load(); } catch(e){}
  window._audioElementCache.set(key, a);
  return a;
}
function getCachedAudioForSong(song){
  const key = cacheKeyForSong(song);
  return window._audioElementCache.get(key) || null;
}

(function setupAudioUnlock(){
  let unlocked = false;
  function unlock(){
    if (unlocked) return;
    unlocked = true;
    try{
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      const ctx = new AC();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.value = 0;
      osc.connect(gain).connect(ctx.destination);
      osc.start();
      ctx.resume().finally(()=>{
        setTimeout(()=>{ try{ osc.stop(); ctx.close(); }catch(e){} }, 60);
      });
    }catch(e){}
  }
  window.addEventListener('pointerdown', unlock, { once: true, passive: true });
})();

function initLazy3D(data){
  function addOverlay(el, text){
    if (!el) return;
    el.style.position = el.style.position || 'relative';
    const overlay = document.createElement('div');
    overlay.className = 'lazy-overlay';
    overlay.style.cssText = 'position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:var(--text-secondary);background:rgba(0,0,0,0.08);backdrop-filter: blur(0px);font-size:12px;letter-spacing:0.3px;';
    overlay.innerHTML = '<span>Chargement‚Ä¶</span>';
    el.appendChild(overlay);
    return overlay;
  }

  const targets = [
    { key:'radial',          el: document.querySelector('#radial .radial-wrap'),  render: ()=>renderRadial3D(data),  handle: ()=>window._chart2 },
    { key:'artists3d',       el: document.getElementById('artists3d-container'), render: ()=>renderTopArtists3D(data), handle: ()=>window._artists3d },
    { key:'mood',            el: document.getElementById('mood-container')?.parentElement, render: ()=>renderMoodExplorer(data), handle: ()=>window._mood3d },
    { key:'genre3d',         el: document.getElementById('genre3D'),             render: ()=>renderGenre3D(data), handle: ()=>window._genre3d }
  ];

  const loaded = new Set();
  const overlays = new Map();
  const observer = new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      const target = targets.find(t=> t.el===entry.target);
      if (!target) return;
      const h = target.handle();
      if (entry.isIntersecting){
        if (!loaded.has(target.key)){
          loaded.add(target.key);
          const ov = overlays.get(target.key) || addOverlay(target.el, 'Chargement‚Ä¶');
          try{ target.render(); } finally { if (ov) setTimeout(()=> ov.remove(), 300); }
        } else if (h && typeof h.resume==='function'){
          h.resume();
        }
      } else {
        if (h && typeof h.pause==='function') h.pause();
      }
    });
  }, { root: null, rootMargin: '0px 0px -10%', threshold: 0.15 });

  targets.forEach(t=>{
    if (t.el){
      const ov = addOverlay(t.el, 'Pr√™t‚Ä¶');
      overlays.set(t.key, ov);
      observer.observe(t.el);
    }
  });
}

  function renderRadial3D(data) {
    const sorted = [...data]
      .sort((a, b) => Number(String(b.streams).replace(/,/g, '')) - Number(String(a.streams).replace(/,/g, '')))
      .slice(0, 12);

    const canvas = document.getElementById('chart2');
    const tooltip = document.querySelector('.chart2-tooltip');
    const container = canvas.closest('.radial-wrap');

    if (window._chart2 && window._chart2.dispose) {
      try { window._chart2.dispose(); } catch(e){}
      window._chart2 = null;
    }

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const p = new THREE.PointLight(0xffffff, 0.9);
    p.position.set(10, 20, 10);
    scene.add(p);

  const circleGeo = new THREE.CircleGeometry(7.2, 64);
  const circleMat = new THREE.MeshBasicMaterial({ color: 0x0b0b0b, transparent: true, opacity: 0.35 });
  const circle = new THREE.Mesh(circleGeo, circleMat);
  circle.rotation.x = -Math.PI/2;
  circle.position.y = -0.25;
  scene.add(circle);

    const group = new THREE.Group();
    scene.add(group);

    const values = sorted.map(s => Number(String(s.streams).replace(/,/g, '')));
    const max = Math.max(...values, 1);

  const radius = 5.05;
  const colRadius = 0.42;
  const maxHeight = 6.2;

    sorted.forEach((s, i) => {
      const val = Number(String(s.streams).replace(/,/g, ''));
      const height = Math.max(0.4, (val / max) * maxHeight);
      const angle = Math.PI * (i / (sorted.length - 1));
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;

      const geo = new THREE.CylinderGeometry(colRadius, colRadius, height, 24);
      const color = new THREE.Color().setHSL(0.33 - (i*0.02), 0.75, 0.38);
      const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.15, roughness: 0.45, emissive: color.clone().multiplyScalar(0.03) });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, height/2 - 0.05, z);
      mesh.lookAt(0, mesh.position.y, 0);
  mesh.userData = { title: s.track_name, artist: s['artist(s)_name'], streams: val, rank: i+1 };
      mesh.scale.y = 0.01;
      gsap.to(mesh.scale, { y: 1, duration: 1.0 + i*0.04, ease: 'elastic.out(1,0.6)' });

      gsap.to(mesh.scale, { x: 1.05, z: 1.05, repeat: -1, yoyo: true, duration: 1.6 + (i*0.02), ease: 'sine.inOut', delay: 1.0 + i*0.02 });

      try {
        const coverSize = Math.min(1.0, colRadius * 2.2);
        const coverGeo = new THREE.PlaneGeometry(coverSize, coverSize);
        const loader = new THREE.TextureLoader();
        const coverTex = loader.load(s.cover_url,
          function(tex){ tex.needsUpdate = true; }
        );
        const coverMat = new THREE.MeshBasicMaterial({ map: coverTex, transparent: true });
        const coverMesh = new THREE.Mesh(coverGeo, coverMat);
        coverMesh.position.set(x, height + 0.7, z);
        
        coverMesh.userData = { isCover: true };
        coverMesh.scale.set(0.01,0.01,0.01);
        group.add(coverMesh);

        
        gsap.to(coverMesh.scale, { x:1, y:1, z:1, duration: 0.6, delay: 0.9 + i*0.03, ease: 'back.out(1.2)' });

        
        gsap.to(coverMesh.position, { y: coverMesh.position.y + 0.06, duration: 1.6 + Math.random(), repeat: -1, yoyo: true, ease: 'sine.inOut' });
      } catch(e) { }
      group.add(mesh);
    });

  
  camera.position.set(0, 9.2, 15);
  camera.lookAt(0, 1.2, 0);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableZoom = false;
    controls.enablePan = false;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.6;
 
  controls.target.set(0, 1.2, 0);
  controls.update();

   
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onMove(e){
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left)/rect.width)*2 -1;
      mouse.y = -((e.clientY - rect.top)/rect.height)*2 +1;
      raycaster.setFromCamera(mouse, camera);
      
      const columns = group.children.filter(obj => obj.userData && obj.userData.title);
      const intr = raycaster.intersectObjects(columns, false);
      if (intr.length>0){
        const m = intr[0].object; const d = m.userData;
        tooltip.style.opacity = '1'; tooltip.style.left = (e.clientX+12)+'px'; tooltip.style.top = (e.clientY+12)+'px';
  tooltip.innerHTML = `#${d.rank} ‚Äî ${d.title}<br><small style=\"opacity:0.8\">${d.artist}</small><br><strong>${Number(d.streams).toLocaleString()} √©coutes</strong>`;
        gsap.to(m.scale, { x:1.08, z:1.08, duration:0.18 });
        group.children.forEach(ch=>{ if (ch!==m) gsap.to(ch.scale,{x:1,z:1,duration:0.18}); });
        document.body.style.cursor='pointer';
      } else { tooltip.style.opacity='0'; group.children.forEach(ch=>gsap.to(ch.scale,{x:1,z:1,duration:0.18})); document.body.style.cursor='default'; }
    }

    canvas.addEventListener('mousemove', onMove);

   
    let raf = null; let _paused = false;
    function animate(){ if (_paused) return; raf = requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
    animate();

    function onResize(){ renderer.setSize(canvas.clientWidth, canvas.clientHeight); camera.aspect = canvas.clientWidth/canvas.clientHeight; camera.updateProjectionMatrix(); }
    window.addEventListener('resize', onResize);

    window._chart2 = {
      pause(){ _paused = true; try{ cancelAnimationFrame(raf);}catch(e){} },
      resume(){ if(!_paused) return; _paused=false; animate(); },
      dispose(){ _paused=true; try{ cancelAnimationFrame(raf);}catch(e){}; window.removeEventListener('resize', onResize); canvas.removeEventListener('mousemove', onMove); try{ controls.dispose(); renderer.dispose(); }catch(e){} }
    };
  }

  
  function _callExtraCharts(data){ renderRadial3D(data); }


  function parseStreams(v){ return Number(String(v).replace(/,/g,''))||0; }
  function safeNum(v){ const n = Number(v); return isFinite(n)&&!isNaN(n) ? n : 0; }
  function daysSinceRelease(y, m, d){
    const year = safeNum(y)||2000; const month = (safeNum(m)||1)-1; const day = safeNum(d)||15;
    const rel = new Date(Date.UTC(year, month, day));
    const now = new Date();
    const diff = Math.max(1, (now - rel) / (1000*60*60*24));
    return diff;
  }
  function zscores(arr){
    const n = arr.length||1; const mean = arr.reduce((a,b)=>a+b,0)/n; const sd = Math.sqrt(arr.reduce((s,x)=>s+Math.pow(x-mean,2),0)/Math.max(1,n-1))||1;
    return arr.map(x => (x-mean)/sd);
  }
  function computeMetrics(data){
  
    const spdArr = [];
    const spCharts = []; const apCharts=[]; const dzCharts=[]; const shCharts=[];
    const rows = data.map(s=>{
      const streams = parseStreams(s.streams);
      const days = daysSinceRelease(s.released_year, s.released_month, s.released_day);
      const spd = streams / Math.max(1, days);
      const sp = safeNum(s.in_spotify_playlists);
      const ap = safeNum(s.in_apple_playlists);
      const dp = safeNum(s.in_deezer_playlists);
      const totalPlaylists = sp+ap+dp;
      const pe = streams / Math.max(1, totalPlaylists);
      const sc = safeNum(s.in_spotify_charts); const ac = safeNum(s.in_apple_charts); const dc = safeNum(s.in_deezer_charts); const sh = safeNum(s.in_shazam_charts);
      spdArr.push(spd); spCharts.push(sc); apCharts.push(ac); dzCharts.push(dc); shCharts.push(sh);
      return { s, streams, spd, totalPlaylists, pe, sc, ac, dc, sh };
    });
    
    const zSpd = zscores(spdArr);
    const zSc = zscores(spCharts), zAc = zscores(apCharts), zDc = zscores(dzCharts), zSh = zscores(shCharts);
    return rows.map((r,i)=>{
      const mpi = zSc[i]+zAc[i]+zDc[i]+zSh[i];
      const virality = 0.6*zSpd[i] + 0.4*mpi;
      return { ...r, zSpd: zSpd[i], mpi, virality };
    });
  }

 
  function renderEfficiencyBoard(data){
    const host = document.getElementById('eff-table'); if(!host) return;
    const rows = computeMetrics(data);
    let sortKey = 'virality'; let sortDir = -1; 
    const shortNum = (n)=>{
      if (n>=1e9) return (n/1e9).toFixed(1).replace(/\.0$/,'')+' Md';
      if (n>=1e6) return (n/1e6).toFixed(1).replace(/\.0$/,'')+' M';
      if (n>=1e3) return (n/1e3).toFixed(1).replace(/\.0$/,'')+' k';
      return String(Math.round(n));
    };
    const header = document.createElement('div');
    header.style.cssText = 'display:grid;grid-template-columns:28px 2fr 1.2fr 90px 70px 70px 70px 70px 80px;align-items:center;gap:8px;padding:8px 6px;border-bottom:1px solid #2a2a2a;color:#b3b3b3;font-size:12px;position:sticky;top:0;background:#121212;z-index:1;';
    const cols = [
      {k:'', label:'#'},
      {k:'track', label:'Titre'},
      {k:'artist', label:'Artiste'},
      {k:'streams', label:'Streams'},
      {k:'spd', label:'SPD'},
      {k:'pe', label:'PE'},
      {k:'mpi', label:'MPI'},
      {k:'zSpd', label:'z(SPD)'},
      {k:'virality', label:'VS'},
    ];
    cols.forEach(c=>{
      const b = document.createElement('button');
      b.textContent = c.label; b.style.cssText='text-align:left;background:none;border:none;color:inherit;font:inherit;cursor:pointer;';
      if (c.k){ b.onclick=()=>{ sortKey=c.k; sortDir = (sortKey===c.k? -sortDir: -1); draw(); }; }
      header.appendChild(b);
    });
    host.innerHTML=''; host.appendChild(header);
    const body = document.createElement('div');
    body.style.cssText='max-height:360px;overflow:auto;';
    host.appendChild(body);

    function draw(){
      const sorted = [...rows].sort((a,b)=> (a[sortKey]??0 - (b[sortKey]??0)) * sortDir);
      body.innerHTML='';
      sorted.slice(0,20).forEach((r,idx)=>{
        const row = document.createElement('div');
        row.style.cssText='display:grid;grid-template-columns:28px 2fr 1.2fr 90px 70px 70px 70px 70px 80px;align-items:center;gap:8px;padding:8px 6px;border-bottom:1px solid #1a1a1a;color:#ddd;font-size:12px;';
        row.onmouseenter=()=>row.style.background='rgba(255,255,255,0.03)';
        row.onmouseleave=()=>row.style.background='transparent';
        const isCollab = (r.s['artist(s)_name']||'').includes(',');
        const cells = [
          `<div style="color:#888;">${idx+1}</div>`,
          `<div style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${r.s.track_name}</div>`,
          `<div style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;${isCollab?'color:#1db954;font-weight:600;':''}">${r.s['artist(s)_name']}</div>`,
          `<div style="color:#1db954;font-weight:600;">${shortNum(r.streams)}</div>`,
          `<div>${shortNum(r.spd)}</div>`,
          `<div>${shortNum(r.pe)}</div>`,
          `<div>${r.mpi.toFixed(2)}</div>`,
          `<div>${r.zSpd.toFixed(2)}</div>`,
          `<div style="font-weight:700;">${r.virality.toFixed(2)}</div>`
        ];
        row.innerHTML = cells.join('');
        row.onclick=()=>{ if (window.loadPlayerTrack) window.loadPlayerTrack(r.s, true); };
        body.appendChild(row);
      });
    }
    draw();
  }

  
  let _yearScatterChart = null;
  function renderYearScatter(data){
    const canvas = document.getElementById('year-scatter-canvas'); if(!canvas) return;
    const ctx = canvas.getContext('2d');
    
    const rect = canvas.getBoundingClientRect(); canvas.width = rect.width*window.devicePixelRatio; canvas.height = rect.height*window.devicePixelRatio; ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

    const metrics = data.map(s=>({
      s,
      streams: parseStreams(s.streams),
      year: safeNum(s.released_year)||0,
      playlists: safeNum(s.in_spotify_playlists)+safeNum(s.in_apple_playlists)+safeNum(s.in_deezer_playlists),
      collab: ((s['artist(s)_name']||'').includes(','))
    })).filter(x=>x.year>0 && x.streams>0);

    
    const getGenre = (song)=> genreByArtist[song['artist(s)_name']] || 'Autre';
    const genres = Array.from(new Set(metrics.map(m=> getGenre(m.s))));
    const colorFor = (g)=>{
      const idx = genres.indexOf(g); const palette=['#1db954','#a78bfa','#60a5fa','#34d399','#f472b6','#f59e0b','#22d3ee','#fb7185','#c084fc'];
      return palette[idx % palette.length];
    };

   
    const sel = document.getElementById('ys-genre'); const cb = document.getElementById('ys-collab');
    if (sel && sel.children.length<=1){ genres.forEach(g=>{ const o=document.createElement('option'); o.value=g; o.textContent=g; sel.appendChild(o); }); }

    function makeDataset(){
      const gFilter = sel ? sel.value : '__ALL__'; const onlyCollab = cb && cb.checked;
      const filtered = metrics.filter(m=> (gFilter==='__ALL__' || getGenre(m.s)===gFilter) && (!onlyCollab || m.collab));
      const groups = {};
      filtered.forEach(m=>{ const g=getGenre(m.s); (groups[g] ||= []).push(m); });
      const ds = Object.entries(groups).map(([g,arr])=>({
        label:g,
        data: arr.map(a=>({x:a.year, y:a.streams, r: Math.min(8, 3 + Math.log10(1+a.playlists)) , s:a.s})),
        pointRadius: ctx=> ctx.raw.r,
        pointHoverRadius: ctx=> (ctx.raw.r||3)+2,
        showLine:false,
        backgroundColor: colorFor(g)
      }));
      return ds;
    }

  
    if (_yearScatterChart){ _yearScatterChart.destroy(); }
    _yearScatterChart = new Chart(canvas, {
      type:'scatter',
      data: { datasets: makeDataset() },
      options:{
        responsive:true, maintainAspectRatio:false,
        plugins:{ legend:{ labels:{ color:'#b3b3b3', boxWidth:10, usePointStyle:true }}, tooltip:{ enabled:false } },
        scales:{
          x:{ type:'linear', title:{ display:true, text:'Ann√©e', color:'#b3b3b3' }, grid:{ color:'#1f1f1f' }, ticks:{ color:'#9a9a9a' } },
          y:{ type:'logarithmic', title:{ display:true, text:'Streams (log)', color:'#b3b3b3' }, grid:{ color:'#1f1f1f' }, ticks:{ color:'#9a9a9a', callback:(v)=>{ const n = Number(v); return n>=1e6? (n/1e6)+'M' : n>=1e3? (n/1e3)+'k' : n; } } }
        },
        onHover:(evt, items)=>{ const tip = document.getElementById('year-scatter-tooltip'); if (!tip) return; if (items.length){ const it = items[0]; const p = it.element; const raw = it.raw; const s = raw.s; tip.style.opacity='1'; tip.style.left = (evt.offsetX+12)+'px'; tip.style.top = (evt.offsetY-12)+'px'; tip.innerHTML = `<strong>${s.track_name}</strong><br><small>${s['artist(s)_name']}</small><br>${parseStreams(s.streams).toLocaleString()} streams`; } else { const tip = document.getElementById('year-scatter-tooltip'); tip.style.opacity='0'; } }
      }
    });

    
    if (sel) sel.onchange = ()=>{ _yearScatterChart.data.datasets = makeDataset(); _yearScatterChart.update(); };
    if (cb) cb.onchange = ()=>{ _yearScatterChart.data.datasets = makeDataset(); _yearScatterChart.update(); };
  }

  
  let _paretoChart = null;
  function renderParetoChart(data){
    const canvas = document.getElementById('pareto-canvas'); if(!canvas) return;
    const nInput = document.getElementById('pareto-n'); const nLabel = document.getElementById('pareto-n-label'); const nInline = document.getElementById('pareto-n-inline'); const shareEl = document.getElementById('pareto-share'); const center = document.getElementById('pareto-center');
    const arr = data.map(s=> parseStreams(s.streams)).filter(Boolean).sort((a,b)=>b-a);
    const total = arr.reduce((a,b)=>a+b,0)||1;
    function calcShare(N){ const top = arr.slice(0,N).reduce((a,b)=>a+b,0); return top/total; }
    function update(){ const N = Number(nInput.value)||10; const share = calcShare(N); if(nLabel) nLabel.textContent=String(N); if(nInline) nInline.textContent=String(N); if(shareEl) shareEl.textContent=(share*100).toFixed(1)+'%'; if(center) center.textContent=(share*100).toFixed(0)+'%'; const dataSet=[share, 1-share]; if (_paretoChart){ _paretoChart.data.datasets[0].data = dataSet; _paretoChart.update(); } }
   
    if (_paretoChart){ _paretoChart.destroy(); }
    _paretoChart = new Chart(canvas, {
      type:'doughnut',
      data:{ labels:['Top N', 'Reste'], datasets:[{ data:[0.5,0.5], backgroundColor:['#1db954','#2a2a2a'], borderColor:['#1db954','#2a2a2a'], borderWidth:1, hoverOffset:4, cutout:'68%' }] },
      options:{ responsive:false, plugins:{ legend:{ display:false } } }
    });
    if (nInput){ nInput.oninput = update; }
    update();
  }


function renderHeatmap(data) {
  const parseStreams = v => Number(String(v).replace(/,/g,'')) || 0;
  const monthNames = ['Jan','F√©v','Mar','Avr','Mai','Jun','Jul','Ao√ª','Sep','Oct','Nov','D√©c'];
  const list = document.getElementById('timeline-list');
  if (!list) return;
  list.innerHTML = '';

  
  const byMonth = {};
  data.forEach(song => {
    const y = Number(song.released_year);
    const m = Number(song.released_month);
    if (!y || !m) return;
    const key = `${y}-${m}`;
    if (!byMonth[key]) byMonth[key] = { year: y, month: m, streams: 0, songs: [] };
    byMonth[key].streams += parseStreams(song.streams);
    byMonth[key].songs.push(song);
  });

  // Sort months descending by year then month
  const ordered = Object.values(byMonth).sort((a,b) => {
    if (b.year === a.year) return b.month - a.month;
    return b.year - a.year;
  });

 
  const metricSelect = document.getElementById('timeline-metric');

  const formatCompact = (n) => {
    if (n >= 1e9) return (n/1e9).toFixed(1).replace(/\.0$/, '') + ' Md';
    if (n >= 1e6) return (n/1e6).toFixed(1).replace(/\.0$/, '') + ' M';
    if (n >= 1e3) return (n/1e3).toFixed(1).replace(/\.0$/, '') + ' k';
    return String(n);
  };

  
  const maxStreams = Math.max(...ordered.map(o => o.streams), 1);

  ordered.forEach(group => {
    const container = document.createElement('div');
    container.style.cssText = 'background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.05);padding:8px 10px;border-radius:8px;display:flex;flex-direction:column;gap:6px;';

    
    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:10px;';
    const left = document.createElement('div');
    left.style.cssText = 'font-size:13px;color:#fff;font-weight:600;';
    left.textContent = `${monthNames[group.month-1]} ${group.year}`;
    const right = document.createElement('div');
    right.style.cssText = 'font-size:11px;color:#1db954;font-weight:600;white-space:nowrap;';
    right.textContent = `${formatCompact(group.streams)} √©coutes ¬∑ ${group.songs.length} titres`;
    header.appendChild(left); header.appendChild(right);
    container.appendChild(header);

    
    const barWrap = document.createElement('div');
    barWrap.style.cssText = 'height:6px;width:100%;background:#0d1117;border-radius:4px;overflow:hidden;position:relative;';
    const barFill = document.createElement('div');
    const pct = group.streams / maxStreams;
    const color = pct < 0.25 ? '#0e4429' : pct < 0.5 ? '#006d32' : pct < 0.75 ? '#26a641' : '#39d353';
    barFill.style.cssText = `height:100%;width:${(pct*100).toFixed(2)}%;background:${color};transition:width 0.8s;`; 
    barWrap.appendChild(barFill);
    container.appendChild(barWrap);

    
    const songsHolder = document.createElement('div');
    songsHolder.style.cssText = 'display:flex;gap:6px;flex-wrap:wrap;';
    const topSongs = group.songs.sort((a,b) => parseStreams(b.streams) - parseStreams(a.streams)).slice(0,3);
    topSongs.forEach(song => {
      const item = document.createElement('div');
      item.style.cssText = 'display:flex;align-items:center;gap:6px;background:rgba(255,255,255,0.04);padding:4px 6px;border-radius:6px;font-size:11px;cursor:pointer;max-width:260px;overflow:hidden;';
      item.innerHTML = `<img src="${song.cover_url}" style="width:32px;height:32px;border-radius:4px;object-fit:cover;">` +
        `<div style="display:flex;flex-direction:column;min-width:0;">` +
        `<span style="color:#fff;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${song.track_name}</span>` +
        `<span style="color:#9fb5a8;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${formatCompact(parseStreams(song.streams))} ¬∑ ${song['artist(s)_name']}</span>` +
        `</div>`;
      item.addEventListener('mouseenter', () => item.style.background = 'rgba(255,255,255,0.07)');
      item.addEventListener('mouseleave', () => item.style.background = 'rgba(255,255,255,0.04)');
      item.addEventListener('click', () => {
        if (window.loadPlayerTrack) window.loadPlayerTrack(song, true); 
      });
      songsHolder.appendChild(item);
    });
    container.appendChild(songsHolder);

    
    const expandBtn = document.createElement('button');
    expandBtn.textContent = 'Voir tout';
    expandBtn.style.cssText = 'align-self:flex-start;margin-top:2px;background:#1db954;color:#fff;border:none;font-size:11px;padding:4px 10px;border-radius:16px;cursor:pointer;transition:background 0.2s;';
    expandBtn.addEventListener('mouseenter', () => expandBtn.style.background = '#1ed760');
    expandBtn.addEventListener('mouseleave', () => expandBtn.style.background = '#1db954');
    container.appendChild(expandBtn);

   
    const fullList = document.createElement('div');
    fullList.style.cssText = 'display:none;flex-direction:column;gap:4px;margin-top:6px;';
    group.songs.sort((a,b) => parseStreams(b.streams) - parseStreams(a.streams)).forEach(song => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex;align-items:center;gap:8px;padding:4px 6px;border-radius:6px;background:rgba(255,255,255,0.03);font-size:11px;cursor:pointer;';
      row.innerHTML = `<img src="${song.cover_url}" style="width:26px;height:26px;border-radius:4px;object-fit:cover;">` +
        `<div style="flex:1;min-width:0;display:flex;flex-direction:column;">` +
        `<span style="color:#fff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:600;">${song.track_name}</span>` +
        `<span style="color:#9fb5a8;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${song['artist(s)_name']}</span>` +
        `</div>` +
        `<span style="color:#1db954;font-weight:600;">${formatCompact(parseStreams(song.streams))}</span>`;
      row.addEventListener('mouseenter', () => row.style.background = 'rgba(255,255,255,0.06)');
      row.addEventListener('mouseleave', () => row.style.background = 'rgba(255,255,255,0.03)');
      row.addEventListener('click', () => {
        if (window.loadPlayerTrack) window.loadPlayerTrack(song, true); 
      });
      fullList.appendChild(row);
    });
    container.appendChild(fullList);

    let expanded = false;
    expandBtn.addEventListener('click', () => {
      expanded = !expanded;
      fullList.style.display = expanded ? 'flex' : 'none';
      expandBtn.textContent = expanded ? 'Fermer' : 'Voir tout';
    });

    list.appendChild(container);
  });

  if (metricSelect) {
    metricSelect.onchange = () => {
      
      const useCount = metricSelect.value === 'count';
      [...list.children].forEach((block, idx) => {
        const grp = ordered[idx];
        const headRight = block.querySelector('div div:last-child');
        if (headRight) {
          headRight.textContent = useCount ? `${grp.songs.length} titres` : `${formatCompact(grp.streams)} √©coutes ¬∑ ${grp.songs.length} titres`;
        }
      });
    };
  }
}


function renderTopArtists3D(data) {
  const container = document.getElementById('artists3d-container');
  const tooltip = document.getElementById('artists3d-tooltip');
  if (!container) return;

 
  const parseStreams = v => Number(String(v).replace(/,/g,'')) || 0;

  
  const artistStats = {};
  data.forEach(song => {
    const artist = song['artist(s)_name'] || 'Unknown';
    const streams = parseStreams(song.streams);
    
    if (!artistStats[artist]) {
      artistStats[artist] = {
        name: artist,
        totalStreams: 0,
        songCount: 0,
        songs: [],
        topSong: null
      };
    }
    
    artistStats[artist].totalStreams += streams;
    artistStats[artist].songCount++;
    artistStats[artist].songs.push(song);
    
  
    if (!artistStats[artist].topSong || streams > parseStreams(artistStats[artist].topSong.streams)) {
      artistStats[artist].topSong = song;
    }
  });


  const topArtists = Object.values(artistStats)
    .sort((a, b) => b.totalStreams - a.totalStreams)
    .slice(0, 15);


  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0a0a);
  

  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 4, 16); 
  camera.lookAt(0, 2.5, 0); 
  
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.innerHTML = '';
  container.appendChild(renderer.domElement);


  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 1.5;
  controls.minDistance = 10; 
  controls.maxDistance = 22; 
  controls.target.set(0, 2.5, 0); 


  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  
  const pointLight1 = new THREE.PointLight(0x1db954, 1.5, 50);
  pointLight1.position.set(10, 10, 10);
  scene.add(pointLight1);
  
  const pointLight2 = new THREE.PointLight(0x1ed760, 1, 50);
  pointLight2.position.set(-10, 10, -10);
  scene.add(pointLight2);


  const gridHelper = new THREE.GridHelper(20, 20, 0x1db954, 0x333333);
  gridHelper.material.transparent = true;
  gridHelper.material.opacity = 0.2;
  scene.add(gridHelper);


  const maxStreams = topArtists[0].totalStreams;
  const bars = [];
  const spacing = 1.0; 
  const totalWidth = (topArtists.length - 1) * spacing;

  topArtists.forEach((artist, index) => {
    const percentage = artist.totalStreams / maxStreams;
    const barHeight = 0.8 + percentage * 3.5; 
    const x = (index * spacing) - (totalWidth / 2);
    
   
    const geometry = new THREE.BoxGeometry(0.65, barHeight, 0.65); 
    
   
    const hue = 0.33 - (index / topArtists.length) * 0.1; 
    const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
    
    const material = new THREE.MeshPhongMaterial({
      color: color,
      emissive: color,
      emissiveIntensity: 0.4,
      shininess: 60,
      transparent: true,
      opacity: 0.9
    });

    const bar = new THREE.Mesh(geometry, material);
    bar.position.set(x, barHeight / 2, 0);
    bar.userData = {
      artist: artist,
      originalColor: color.clone(),
      originalEmissive: 0.4,
      originalHeight: barHeight,
      index: index
    };

    scene.add(bar);
    bars.push(bar);

    
    if (artist.topSong && artist.topSong.cover_url) {
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(
        artist.topSong.cover_url,
        (texture) => {
          const coverSize = 0.55; 
          const coverGeometry = new THREE.PlaneGeometry(coverSize, coverSize);
          const coverMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            opacity: 0.95,
            side: THREE.DoubleSide
          });
          const cover = new THREE.Mesh(coverGeometry, coverMaterial);
          cover.position.set(x, barHeight + 0.4, 0); 
          cover.renderOrder = 999;
          cover.material.depthTest = false;
          scene.add(cover);
          bar.userData.cover = cover;
        },
        undefined,
        (error) => {
          console.log('Cover load failed for', artist.name);
        }
      );
    }

    
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#1db954';
    ctx.font = 'bold 80px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`#${index + 1}`, 64, 64);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.set(x, -0.6, 0); 
    sprite.scale.set(0.65, 0.65, 1); 
  });

 
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let hoveredBar = null;

  const canvas = renderer.domElement;
  canvas.addEventListener('mousemove', (event) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(bars);

    
    if (hoveredBar && (!intersects.length || intersects[0].object !== hoveredBar)) {
      const userData = hoveredBar.userData;
      hoveredBar.material.emissiveIntensity = userData.originalEmissive;
      gsap.to(hoveredBar.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
      hoveredBar = null;
      tooltip.style.opacity = '0';
      canvas.style.cursor = 'grab';
      controls.autoRotate = true;
    }

    if (intersects.length > 0) {
      const bar = intersects[0].object;
      const artist = bar.userData.artist;

      if (hoveredBar !== bar) {
        hoveredBar = bar;
        bar.material.emissiveIntensity = 1;
        gsap.to(bar.scale, { x: 1.15, y: 1.05, z: 1.15, duration: 0.3, ease: 'back.out(2)' });
        canvas.style.cursor = 'pointer';
        controls.autoRotate = false;

      
        const avgStreamsPerSong = Math.floor(artist.totalStreams / artist.songCount);
        tooltip.innerHTML = `
          <div style="font-weight:700;font-size:14px;margin-bottom:4px;color:#1db954;">
            #${bar.userData.index + 1} ‚Äî ${artist.name}
          </div>
          <div style="font-size:11px;color:#bbb;margin-bottom:6px;">
            ${artist.songCount} chanson${artist.songCount > 1 ? 's' : ''} dans le top
          </div>
          <div style="font-size:10px;color:#888;line-height:1.5;">
            <strong>Total streams:</strong> ${artist.totalStreams.toLocaleString()}<br>
            <strong>Moyenne/chanson:</strong> ${avgStreamsPerSong.toLocaleString()}<br>
            <strong>Top hit:</strong> ${artist.topSong.track_name}
          </div>
        `;
        tooltip.style.opacity = '1';
      }
    }
  });

  canvas.addEventListener('click', () => {
    if (hoveredBar && window.loadPlayerTrack) {
      const artist = hoveredBar.userData.artist;
      window.loadPlayerTrack(artist.topSong, true);
    }
  });

 
  let _rafId = null; let _paused = false;
  function animate() {
    if (_paused) return;
    _rafId = requestAnimationFrame(animate);
    
    
    bars.forEach(bar => {
      if (bar.userData.cover) {
        bar.userData.cover.lookAt(camera.position);
      }
    });
    
    controls.update();
    renderer.render(scene, camera);
  }
  animate();


  window.addEventListener('resize', () => {
    const width = container.clientWidth;
    const height = container.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  });
  const _onResize = ( )=>{
    const width = container.clientWidth;
    const height = container.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  };
  window.removeEventListener('resize', _onResize);
  window.addEventListener('resize', _onResize);

 
  const particlesGeometry = new THREE.BufferGeometry();
  const particlesCount = 500;
  const posArray = new Float32Array(particlesCount * 3);

  for (let i = 0; i < particlesCount; i++) {
    posArray[i * 3 + 0] = (Math.random() - 0.5) * 30;
    posArray[i * 3 + 1] = Math.random() * 15;
    posArray[i * 3 + 2] = (Math.random() - 0.5) * 30;
  }

  particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  const particlesMaterial = new THREE.PointsMaterial({
    size: 0.03,
    color: 0x1db954,
    transparent: true,
    opacity: 0.2,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
  scene.add(particlesMesh);

  gsap.to(particlesMesh.rotation, {
    y: Math.PI * 2,
    duration: 80,
    repeat: -1,
    ease: 'none'
  });
  
  window._artists3d = {
    pause(){ try{ cancelAnimationFrame(_rafId); }catch(e){} _paused = true; },
    resume(){ if (!_paused) return; _paused = false; try{ requestAnimationFrame(()=>{ animate(); }); }catch(e){} },
    dispose(){ try{ cancelAnimationFrame(_rafId);}catch(e){}; try{ renderer.dispose(); controls.dispose(); }catch(e){}; try{ window.removeEventListener('resize', _onResize); }catch(e){} }
  };
}


function renderMoodExplorer(data) {
  const container = document.getElementById('mood-container');
  const tooltip = document.getElementById('mood-tooltip');
  const moodSelect = document.getElementById('mood-select');
  if (!container) return;

 
  const parseStreams = v => Number(String(v).replace(/,/g,'')) || 0;
  const validSongs = data.filter(s => {
    const valence = Number(s['valence_%']);
    const energy = Number(s['energy_%']);
    return !isNaN(valence) && !isNaN(energy);
  });

 
  const topSongs = validSongs
    .sort((a, b) => parseStreams(b.streams) - parseStreams(a.streams))
    .slice(0, 150);

 
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0a0a);
  
  const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 0, 12);
  
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.innerHTML = '';
  container.appendChild(renderer.domElement);

 
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.autoRotate = false;
  controls.minDistance = 8;
  controls.maxDistance = 20;
  controls.enablePan = false;

 
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  
  const pointLight1 = new THREE.PointLight(0x1db954, 1.2, 40);
  pointLight1.position.set(8, 8, 8);
  scene.add(pointLight1);
  
  const pointLight2 = new THREE.PointLight(0xff6b9d, 0.8, 40);
  pointLight2.position.set(-8, 5, -8);
  scene.add(pointLight2);

 
  const quadrants = [
    { name: 'Joyeux & √ânergique', x: 7, y: 8 },
    { name: 'Triste & √ânergique', x: -7, y: 8 },
    { name: 'Joyeux & Calme', x: 7, y: -8 },
    { name: 'Triste & Calme', x: -7, y: -8 }
  ];

  quadrants.forEach(quad => {
   
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#888888';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(quad.name, 128, 32);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.5 });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.set(quad.x, quad.y, -1);
    sprite.scale.set(3.5, 0.9, 1);
    scene.add(sprite);
  });

 
  const axesMaterial = new THREE.LineBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.3 });
  
  
  const hLineGeometry = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-10, 0, 0),
    new THREE.Vector3(10, 0, 0)
  ]);
  scene.add(new THREE.Line(hLineGeometry, axesMaterial));
  
  
  const vLineGeometry = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, -10, 0),
    new THREE.Vector3(0, 10, 0)
  ]);
  scene.add(new THREE.Line(vLineGeometry, axesMaterial));


  const axisLabels = [
    { text: 'Triste', x: -10.5, y: 0, size: 1.2 },
    { text: 'Joyeux', x: 10.5, y: 0, size: 1.2 },
    { text: 'Calme', x: 0, y: -10.5, size: 1.2 },
    { text: '√ânergique', x: 0, y: 10.5, size: 1.2 }
  ];

  axisLabels.forEach(label => {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#1db954'; 
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label.text, 64, 32);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.7 });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.set(label.x, label.y, 0);
    sprite.scale.set(label.size, label.size * 0.5, 1);
    scene.add(sprite);
  });

  
  const covers = [];
  const maxStreams = Math.max(...topSongs.map(s => parseStreams(s.streams)));
  const textureLoader = new THREE.TextureLoader();

  topSongs.forEach(song => {
    const valence = Number(song['valence_%']) || 50;
    const energy = Number(song['energy_%']) || 50;
    const danceability = Number(song['danceability_%']) || 50;
    const streams = parseStreams(song.streams);

    
    const x = ((valence - 50) / 5); 
    const y = ((energy - 50) / 5); 
    const z = (Math.random() - 0.5) * 3; 

    
    const size = 0.35 + (streams / maxStreams) * 0.5;

    
    const group = new THREE.Group();
    group.position.set(x, y, z);

   
    textureLoader.load(
      song.cover_url,
      (texture) => {
        const coverGeometry = new THREE.PlaneGeometry(size, size);
        const coverMaterial = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          opacity: 0.95,
          side: THREE.DoubleSide
        });
        const cover = new THREE.Mesh(coverGeometry, coverMaterial);
        group.add(cover);
        
        group.userData.coverMesh = cover;
      },
      undefined,
      (error) => {
        
        const fallbackGeometry = new THREE.PlaneGeometry(size, size);
        const fallbackMaterial = new THREE.MeshBasicMaterial({
          color: 0x333333,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
        const fallback = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
        group.add(fallback);
      }
    );

    group.userData = {
      song: song,
      valence: valence,
      energy: energy,
      visible: true
    };

    scene.add(group);
    covers.push(group);
  });

  
  let activeFilter = null;

  
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let hoveredCover = null;

  const canvas = renderer.domElement;
  canvas.addEventListener('mousemove', (event) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const visibleCovers = covers.filter(c => c.userData.visible && c.visible);
    const intersects = raycaster.intersectObjects(visibleCovers, true);

    
    if (hoveredCover && (!intersects.length || !intersects[0].object.parent || intersects[0].object.parent !== hoveredCover)) {
      gsap.to(hoveredCover.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
      hoveredCover = null;
      tooltip.style.opacity = '0';
      canvas.style.cursor = 'grab';
    }

    if (intersects.length > 0) {
      
      let cover = intersects[0].object.parent;
      if (!cover || !cover.userData.song) {
        cover = intersects[0].object;
        if (cover.parent && cover.parent.userData.song) {
          cover = cover.parent;
        }
      }
      
      const song = cover.userData.song;
      if (!song) return;

      if (hoveredCover !== cover) {
        hoveredCover = cover;
        
       
        gsap.to(cover.scale, { x: 1.3, y: 1.3, z: 1, duration: 0.3, ease: 'back.out(2)' });
        canvas.style.cursor = 'pointer';

       
        const v = cover.userData.valence;
        const e = cover.userData.energy;
        let mood = '';
        if (v >= 50 && e >= 50) mood = 'üòä Joyeux & √ânergique';
        else if (v < 50 && e >= 50) mood = 'üò§ Triste & √ânergique';
        else if (v >= 50 && e < 50) mood = 'üòå Joyeux & Calme';
        else mood = 'üòî Triste & Calme';

        tooltip.innerHTML = `
          <div style="font-weight:700;font-size:13px;margin-bottom:4px;color:#1db954;">${song.track_name}</div>
          <div style="font-size:11px;color:#bbb;margin-bottom:6px;">${song['artist(s)_name']}</div>
          <div style="font-size:10px;color:#888;line-height:1.5;">
            <strong>Mood:</strong> ${mood}<br>
            <strong>Valence:</strong> ${v}% ¬∑ <strong>√ânergie:</strong> ${e}%<br>
            <strong>Dansabilit√©:</strong> ${song['danceability_%']}%<br>
            <strong>Streams:</strong> ${parseStreams(song.streams).toLocaleString()}
          </div>
          <div style="margin-top:6px;font-size:9px;color:#1db954;font-style:italic;">Cliquez pour √©couter !</div>
        `;
        tooltip.style.opacity = '1';
      }
    }
  });

  canvas.addEventListener('click', () => {
    if (hoveredCover && window.loadPlayerTrack) {
      const song = hoveredCover.userData.song;
      window.loadPlayerTrack(song, true);
    }
  });

  
  moodSelect.addEventListener('change', () => {
    const mood = moodSelect.value;
    
    
    if (!mood) {
      activeFilter = null;
      covers.forEach(cover => {
        cover.userData.visible = true;
        
        cover.children.forEach(child => {
          if (child.material) {
            gsap.to(child.material, { 
              opacity: 0.95, 
              duration: 0.5 
            });
          }
        });
        
        gsap.to(cover.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
      });
      return;
    }
    
   
    const moodMap = {
      'joyeuxEnergetique': 'Joyeux & √ânergique',
      'joyeuxCalme': 'Joyeux & Calme',
      'tristeEnergetique': 'Triste & √ânergique',
      'tristeCalme': 'Triste & Calme'
    };
    
    activeFilter = moodMap[mood];
    
    
    covers.forEach(cover => {
      const v = cover.userData.valence;
      const e = cover.userData.energy;
      let coverMood = '';
      if (v >= 50 && e >= 50) coverMood = 'Joyeux & √ânergique';
      else if (v < 50 && e >= 50) coverMood = 'Triste & √ânergique';
      else if (v >= 50 && e < 50) coverMood = 'Joyeux & Calme';
      else coverMood = 'Triste & Calme';

      const shouldShow = coverMood === activeFilter;
      cover.userData.visible = shouldShow;
      
      cover.children.forEach(child => {
        if (child.material) {
          gsap.to(child.material, {
            opacity: shouldShow ? 0.95 : 0.15,
            duration: 0.5
          });
        }
      });
      
      gsap.to(cover.scale, {
        x: shouldShow ? 1 : 0.5,
        y: shouldShow ? 1 : 0.5,
        z: shouldShow ? 1 : 0.5,
        duration: 0.5
      });
    });
  });

 
  let _rafMood = null; let _pausedMood = false;
  function animate() {
    if (_pausedMood) return;
    _rafMood = requestAnimationFrame(animate);
    const time = Date.now() * 0.0003;
    covers.forEach((cover, i) => {
      cover.position.z += Math.sin(time + i * 0.1) * 0.002;
      cover.lookAt(camera.position);
    });
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

 
  const _onResizeMood = () => {
    const width = container.clientWidth;
    const height = container.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  };
  window.addEventListener('resize', _onResizeMood);

  
  const particlesGeometry = new THREE.BufferGeometry();
  const particlesCount = 300;
  const posArray = new Float32Array(particlesCount * 3);

  for (let i = 0; i < particlesCount; i++) {
    posArray[i * 3 + 0] = (Math.random() - 0.5) * 30;
    posArray[i * 3 + 1] = (Math.random() - 0.5) * 30;
    posArray[i * 3 + 2] = (Math.random() - 0.5) * 15;
  }

  particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  const particlesMaterial = new THREE.PointsMaterial({
    size: 0.03,
    color: 0x1db954,
    transparent: true,
    opacity: 0.2,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
  scene.add(particlesMesh);

  gsap.to(particlesMesh.rotation, {
    y: Math.PI * 2,
    duration: 100,
    repeat: -1,
    ease: 'none'
  });
  window._mood3d = {
    pause(){ _pausedMood = true; try{ cancelAnimationFrame(_rafMood);}catch(e){} },
    resume(){ if(!_pausedMood) return; _pausedMood=false; animate(); },
    dispose(){ _pausedMood=true; try{ cancelAnimationFrame(_rafMood);}catch(e){}; try{ window.removeEventListener('resize', _onResizeMood);}catch(e){}; try{ renderer.dispose(); controls.dispose(); }catch(e){} }
  };
}


function initHigherOrLower(data) {
  
  const parseStreams = v => Number(String(v).replace(/,/g, '')) || 0;
  const validSongs = data.filter(s => {
    const streams = parseStreams(s.streams);
    return streams > 0 && s.track_name && s["artist(s)_name"] && s.cover_url;
  });

  if (validSongs.length < 10) {
    console.error('Not enough valid songs for game');
    return;
  }

 
  let score = 0;
  let streak = 0;
  let bestScore = parseInt(localStorage.getItem('higherLowerBest')) || 0;
  let currentSong = null;
  let nextSong = null;
  let usedIndices = new Set();
  let isAnimating = false;

 
  const scoreEl = document.getElementById('game-score');
  const streakEl = document.getElementById('game-streak');
  const bestEl = document.getElementById('game-best');
  const leftCover = document.getElementById('left-cover');
  const leftTitle = document.getElementById('left-title');
  const leftArtist = document.getElementById('left-artist');
  const leftStreams = document.getElementById('left-streams');
  const rightCover = document.getElementById('right-cover');
  const rightTitle = document.getElementById('right-title');
  const rightArtist = document.getElementById('right-artist');
  const rightMystery = document.getElementById('right-mystery');
  const rightRevealed = document.getElementById('right-revealed');
  const rightStreams = document.getElementById('right-streams');
  const btnHigher = document.getElementById('btn-higher');
  const btnLower = document.getElementById('btn-lower');
  const actionButtons = document.getElementById('action-buttons');
  const resultMessage = document.getElementById('result-message');
  const gameOver = document.getElementById('game-over');
  const finalScore = document.getElementById('final-score');
  const btnRestart = document.getElementById('btn-restart');
  const btnQuit = document.getElementById('btn-quit');

  bestEl.textContent = bestScore;

  
  function getRandomSong() {
    if (usedIndices.size >= validSongs.length) {
      usedIndices.clear(); 
    }
    let index;
    do {
      index = Math.floor(Math.random() * validSongs.length);
    } while (usedIndices.has(index));
    usedIndices.add(index);
    return validSongs[index];
  }

  
  function formatStreams(num) {
    if (num >= 1000000000) return (num / 1000000000).toFixed(1) + 'B';
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
  }


  function updateLeftCard(song) {
    leftCover.src = song.cover_url;
    leftTitle.textContent = song.track_name.length > 40 ? song.track_name.substring(0, 37) + '...' : song.track_name;
    leftArtist.textContent = song["artist(s)_name"].length > 35 ? song["artist(s)_name"].substring(0, 32) + '...' : song["artist(s)_name"];
    leftStreams.textContent = formatStreams(parseStreams(song.streams));
    
    
    leftCover.parentElement.parentElement.songData = song;
  }

  
  function updateRightCard(song) {
    rightCover.src = song.cover_url;
    rightTitle.textContent = song.track_name.length > 40 ? song.track_name.substring(0, 37) + '...' : song.track_name;
    rightArtist.textContent = song["artist(s)_name"].length > 35 ? song["artist(s)_name"].substring(0, 32) + '...' : song["artist(s)_name"];
    rightMystery.style.display = 'block';
    rightRevealed.style.display = 'none';
    
   
    rightCover.parentElement.parentElement.songData = song;
  }

 
  function revealRightCard() {
    rightMystery.style.display = 'none';
    rightRevealed.style.display = 'block';
    rightStreams.textContent = formatStreams(parseStreams(nextSong.streams));
    
  
    gsap.from(rightRevealed, {
      scale: 0,
      rotation: 360,
      duration: 0.6,
      ease: 'back.out(1.7)'
    });
  }


  function showResult(isCorrect) {
    resultMessage.style.opacity = '1';
    resultMessage.style.transform = 'translateY(0)';
    if (isCorrect) {
        resultMessage.textContent = '‚ú® Correct ! +1 point';
      resultMessage.style.background = 'linear-gradient(135deg, rgba(29,185,84,0.2), rgba(29,185,84,0.1))';
      resultMessage.style.border = '2px solid rgba(29,185,84,0.5)';
      resultMessage.style.color = '#1db954';
      resultMessage.style.boxShadow = '0 8px 24px rgba(29,185,84,0.3)';
      
     
      gsap.to(resultMessage, { scale: 1.1, duration: 0.2, yoyo: true, repeat: 1 });
    } else {
        resultMessage.textContent = '‚ùå Faux ! Game Over';
      resultMessage.style.background = 'linear-gradient(135deg, rgba(255,107,107,0.2), rgba(255,107,107,0.1))';
      resultMessage.style.border = '2px solid rgba(255,107,107,0.5)';
      resultMessage.style.color = '#ff6b6b';
      resultMessage.style.boxShadow = '0 8px 24px rgba(255,107,107,0.3)';
      
   
      gsap.to(resultMessage, { x: -10, duration: 0.05, yoyo: true, repeat: 5 });
    }
    
    setTimeout(() => {
      resultMessage.style.opacity = '0';
      resultMessage.style.transform = 'translateY(-10px)';
    }, 1800);
  }

  
  function handleAnswer(isHigher) {
    if (isAnimating) return;
    isAnimating = true;

    const currentStreams = parseStreams(currentSong.streams);
    const nextStreams = parseStreams(nextSong.streams);
    const isCorrect = (isHigher && nextStreams >= currentStreams) || (!isHigher && nextStreams <= currentStreams);

   
    btnHigher.style.pointerEvents = 'none';
    btnLower.style.pointerEvents = 'none';

 
    revealRightCard();

    setTimeout(() => {
      if (isCorrect) {
      
        score++;
        streak++;
        scoreEl.textContent = score;
        streakEl.textContent = streak;
        
        if (score > bestScore) {
          bestScore = score;
          bestEl.textContent = bestScore;
          localStorage.setItem('higherLowerBest', bestScore);
          
          
          gsap.to(bestEl.parentElement, {
            boxShadow: '0 8px 40px rgba(147,51,234,0.5)',
            duration: 0.3,
            yoyo: true,
            repeat: 3
          });
          gsap.to(bestEl, {
            scale: 1.4,
            duration: 0.4,
            ease: 'elastic.out(1, 0.5)',
            yoyo: true,
            repeat: 1
          });
        }

       
        gsap.to(scoreEl.parentElement, {
          boxShadow: '0 8px 32px rgba(29,185,84,0.4)',
          duration: 0.2,
          yoyo: true,
          repeat: 1
        });
        
     
        if (streak > 1) {
          gsap.from(streakEl, {
            scale: 0.5,
            duration: 0.5,
            ease: 'elastic.out(1, 0.6)'
          });
        }

        showResult(true);

        
        setTimeout(() => {
          currentSong = nextSong;
          nextSong = getRandomSong();
         
          prewarmAudioForSong(nextSong).catch(()=>{});
          
        
          gsap.to('#left-card', {
            opacity: 0.3,
            x: -50,
            duration: 0.3,
            onComplete: () => {
              updateLeftCard(currentSong);
              gsap.to('#left-card', { opacity: 1, x: 0, duration: 0.4, ease: 'power2.out' });
            }
          });
          
          gsap.to('#right-card', {
            opacity: 0.3,
            x: -50,
            duration: 0.3,
            onComplete: () => {
              updateRightCard(nextSong);
              gsap.to('#right-card', { opacity: 1, x: 0, duration: 0.4, ease: 'power2.out' });
            }
          });
          
          setTimeout(() => {
            btnHigher.style.pointerEvents = 'auto';
            btnLower.style.pointerEvents = 'auto';
            isAnimating = false;
          }, 400);
        }, 1200);
      } else {
        
        streak = 0;
        streakEl.textContent = '0';
        showResult(false);
        
        setTimeout(() => {
          endGame();
        }, 1500);
      }
    }, 600);
  }

 
  function endGame() {
    finalScore.textContent = score;
    gameOver.style.display = 'flex';
    gsap.from(gameOver, {
      opacity: 0,
      scale: 0.8,
      duration: 0.5,
      ease: 'back.out(1.7)'
    });
  }

 
  function startGame() {
    score = 0;
    streak = 0;
    usedIndices.clear();
    isAnimating = false;
    
    scoreEl.textContent = '0';
    streakEl.textContent = '0';
    
    currentSong = getRandomSong();
  nextSong = getRandomSong();
  
  prewarmAudioForSong(currentSong).catch(()=>{});
  prewarmAudioForSong(nextSong).catch(()=>{});
    
    updateLeftCard(currentSong);
    updateRightCard(nextSong);
    
    gameOver.style.display = 'none';
    btnHigher.style.pointerEvents = 'auto';
    btnLower.style.pointerEvents = 'auto';
    
    
    gsap.from('#left-card', { 
      x: -100, 
      opacity: 0, 
      duration: 0.8, 
      ease: 'power3.out',
      clearProps: 'all'
    });
    gsap.from('#right-card', { 
      x: 100, 
      opacity: 0, 
      duration: 0.8, 
      delay: 0.15, 
      ease: 'power3.out',
      clearProps: 'all'
    });
    gsap.from('#action-buttons', {
      y: 30,
      opacity: 0,
      duration: 0.6,
      delay: 0.4,
      ease: 'power2.out'
    });
  }

  
  btnHigher.addEventListener('mouseenter', () => {
    gsap.to(btnHigher, { scale: 1.08, y: -4, duration: 0.3, ease: 'power2.out' });
  });
  btnHigher.addEventListener('mouseleave', () => {
    gsap.to(btnHigher, { scale: 1, y: 0, duration: 0.3, ease: 'power2.out' });
  });
  btnLower.addEventListener('mouseenter', () => {
    gsap.to(btnLower, { scale: 1.08, y: -4, duration: 0.3, ease: 'power2.out' });
  });
  btnLower.addEventListener('mouseleave', () => {
    gsap.to(btnLower, { scale: 1, y: 0, duration: 0.3, ease: 'power2.out' });
  });
  btnRestart.addEventListener('mouseenter', () => {
    gsap.to(btnRestart, { scale: 1.08, y: -4, duration: 0.3, ease: 'power2.out' });
  });
  btnRestart.addEventListener('mouseleave', () => {
    gsap.to(btnRestart, { scale: 1, y: 0, duration: 0.3, ease: 'power2.out' });
  });
  if (btnQuit){
    btnQuit.addEventListener('mouseenter', () => {
      gsap.to(btnQuit, { scale: 1.08, y: -4, duration: 0.3, ease: 'power2.out' });
    });
    btnQuit.addEventListener('mouseleave', () => {
      gsap.to(btnQuit, { scale: 1, y: 0, duration: 0.3, ease: 'power2.out' });
    });
  }

  
  btnHigher.addEventListener('click', () => handleAnswer(true));
  btnLower.addEventListener('click', () => handleAnswer(false));
  btnRestart.addEventListener('click', startGame);
  if (btnQuit){
    btnQuit.addEventListener('click', () => {
      
      gameOver.style.display = 'none';
     
      document.getElementById('left-card').style.opacity = '0.35';
      document.getElementById('right-card').style.opacity = '0.35';
      btnHigher.style.pointerEvents = 'none';
      btnLower.style.pointerEvents = 'none';
      
      if (!document.getElementById('quit-banner')){
        const banner = document.createElement('div');
        banner.id = 'quit-banner';
        banner.style.cssText = 'margin-top:10px;padding:10px;border:1px dashed var(--border);border-radius:6px;font-size:10px;text-align:center;color:var(--text-secondary);';
        banner.innerHTML = 'Jeu arr√™t√©. <button id="btn-return" style="background:#1db954;border:none;color:#000;padding:5px 12px;border-radius:12px;font-size:10px;font-weight:600;cursor:pointer;margin-left:6px;">Revenir</button>';
        gameOver.parentElement.appendChild(banner);
        banner.querySelector('#btn-return').addEventListener('click', () => {
         
          document.getElementById('left-card').style.opacity = '1';
          document.getElementById('right-card').style.opacity = '1';
          if (banner.parentElement) banner.parentElement.removeChild(banner);
          startGame();
        });
      }
    });
  }

  
  document.addEventListener('keydown', (e) => {
    if (gameOver.style.display === 'flex') {
      if (e.key === 'Enter' || e.key === ' ') {
        startGame();
      }
      return;
    }
    
    if (isAnimating) return;
    
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
      handleAnswer(true);
    } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
      handleAnswer(false);
    }
  });

  
  let hoverAudio = null;
  let hoverLoadingToken = 0;
  const leftCard = document.getElementById('left-card');
  const rightCard = document.getElementById('right-card');
  
  async function loadHoverAudio(song, forcePlay=false) {
    if (!song) return;
    if (hoverAudio) { hoverAudio.pause(); hoverAudio.currentTime = 0; hoverAudio = null; }
    const myToken = ++hoverLoadingToken;
    
    let audio = getCachedAudioForSong(song);
    if (!audio){
     
      audio = await prewarmAudioForSong(song);
      if (!audio) return;
    }
    
    audio.currentTime = 0;
    audio.volume = 0.4;
    try{
      const playPromise = audio.play();
      if (playPromise) await playPromise;
      if (myToken === hoverLoadingToken){ hoverAudio = audio; }
      else { audio.pause(); audio.currentTime = 0; }
    }catch(e){  }
  }

  const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
  if (!isTouch){
    leftCard.addEventListener('mouseenter', ()=> loadHoverAudio(leftCard.songData));
    leftCard.addEventListener('mouseleave', ()=>{ hoverLoadingToken++; if(hoverAudio){ hoverAudio.pause(); hoverAudio=null; } });
    rightCard.addEventListener('mouseenter', ()=> loadHoverAudio(rightCard.songData));
    rightCard.addEventListener('mouseleave', ()=>{ hoverLoadingToken++; if(hoverAudio){ hoverAudio.pause(); hoverAudio=null; } });
  } else {
    
    function toggleCardAudio(card){
      const song = card.songData;
      if (!song) return;
      if (hoverAudio){ hoverAudio.pause(); hoverAudio = null; return; }
      loadHoverAudio(song, true);
    }
    leftCard.addEventListener('touchstart', ()=> toggleCardAudio(leftCard), {passive:true});
    rightCard.addEventListener('touchstart', ()=> toggleCardAudio(rightCard), {passive:true});
  }

 
  startGame();
}


function initSwipePlaylist(data) {
  
  const parseStreams = v => Number(String(v).replace(/,/g, '')) || 0;
  const validSongs = data.filter(s => {
    const streams = parseStreams(s.streams);
    return streams > 0 && s.track_name && s["artist(s)_name"] && s.cover_url;
  });

  if (validSongs.length < 10) {
    console.error('Not enough songs for swipe playlist');
    return;
  }

 
  const shuffled = [...validSongs].sort(() => Math.random() - 0.5);
  
 
  let currentIndex = 0;
  let likedSongs = [];
  let totalSwiped = 0;
  let swipedGenres = {};
  let swipedMoods = { joyeux: 0, triste: 0, energique: 0, calme: 0 };
  let swipedFeatures = { danceability: [], energy: [], valence: [], acousticness: [] };
  
 
  const swipeDeck = document.getElementById('swipe-deck');
  const likeBtn = document.getElementById('like-btn');
  const dislikeBtn = document.getElementById('dislike-btn');
  const resetBtn = document.getElementById('reset-swipe');
  const exportBtn = document.getElementById('export-playlist');
  const likedCountEl = document.getElementById('liked-count');
  const totalSwipedEl = document.getElementById('total-swiped');
  const likedListEl = document.getElementById('liked-songs-list');
  const swipeEndMessage = document.getElementById('swipe-end-message');
  
  let genrePieChart = null;
  let moodRadarChart = null;
  
  
  function getSongGenre(song) {
    const artist = song["artist(s)_name"];
    if (!artist) return 'Other';
    const mainArtist = artist.split(',')[0].split('feat')[0].trim();
    return genreByArtist[mainArtist] || 'Other';
  }
  
  
  function getSongMood(song) {
    const valence = parseFloat(song['valence_%']) || 50;
    const energy = parseFloat(song['energy_%']) || 50;
    
    if (valence >= 50 && energy >= 50) return 'joyeux';
    if (valence < 50 && energy >= 50) return 'energique';
    if (valence < 50 && energy < 50) return 'triste';
    return 'calme';
  }
  
  
  function createCard(song, index) {
    const card = document.createElement('div');
    card.className = 'swipe-card';
    card.style.zIndex = shuffled.length - index;
    
    const genre = getSongGenre(song);
    const mood = getSongMood(song);
    const streams = formatStreams(parseStreams(song.streams));
    
    card.innerHTML = `
      <img class="swipe-card-image" src="${song.cover_url}" alt="${song.track_name}">
      <div class="swipe-card-info">
        <div class="swipe-card-title">${song.track_name}</div>
        <div class="swipe-card-artist">${song["artist(s)_name"]}</div>
        <div class="swipe-card-badges">
          <span class="badge">${genre}</span>
          <span class="badge">${mood}</span>
          <span class="badge">${streams} streams</span>
        </div>
      </div>
    `;
    
    card.dataset.index = index;
    card.dataset.genre = genre;
    card.dataset.mood = mood;
    
    
    card.songData = song;
    
    return card;
  }
  
  
  function formatStreams(num) {
    if (num >= 1000000000) return (num / 1000000000).toFixed(1) + 'B';
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
  }
  
  
  function initCards() {
    swipeDeck.innerHTML = '';
    const cardsToRender = Math.min(3, shuffled.length);
    for (let i = currentIndex; i < currentIndex + cardsToRender && i < shuffled.length; i++) {
      const card = createCard(shuffled[i], i);
      swipeDeck.appendChild(card);
      
      
      if (i === currentIndex) {
        setupCardDrag(card);
      }
      
      
      if (i < currentIndex + 2) {
        prewarmAudioForSong(shuffled[i]).catch(() => {});
      }
    }
  }
  
  
  function setupCardDrag(card) {
    let startX = 0;
    let startY = 0;
    let isDragging = false;
    let currentX = 0;
    
    const onMove = (e) => {
      if (!isDragging) return;
      e.preventDefault();
      
      const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
      const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
      
      currentX = clientX - startX;
      const currentY = clientY - startY;
      const rotation = currentX / 20;
      
      card.style.transform = `translate(${currentX}px, ${currentY}px) rotate(${rotation}deg)`;
      
      
      const opacity = Math.abs(currentX) / 100;
      if (currentX > 0) {
        card.style.borderColor = `rgba(29, 185, 84, ${Math.min(opacity, 1)})`;
      } else {
        card.style.borderColor = `rgba(255, 68, 88, ${Math.min(opacity, 1)})`;
      }
    };
    
    const onEnd = () => {
      if (!isDragging) return;
      isDragging = false;
      card.classList.remove('dragging');
      
      
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onEnd);
      
     
      if (Math.abs(currentX) > 80) {
        if (currentX > 0) {
          swipeRight(card);
        } else {
          swipeLeft(card);
        }
      } else {
        
        card.style.transition = 'transform 0.3s ease, border-color 0.3s ease';
        card.style.transform = '';
        card.style.borderColor = '';
        setTimeout(() => {
          card.style.transition = '';
        }, 300);
      }
      
      currentX = 0;
    };
    
    const onStart = (e) => {
      
      if (isDragging) return;
      
      isDragging = true;
      startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
      startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
      currentX = 0;
      card.classList.add('dragging');
      
      
      if (e.type === 'mousedown') {
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onEnd);
      }
    };
    
    
    card.addEventListener('touchstart', onStart, { passive: false });
    card.addEventListener('touchmove', onMove, { passive: false });
    card.addEventListener('touchend', onEnd);
    
    
    card.addEventListener('mousedown', onStart);
  }
  
  
  function swipeRight(card) {
    card.classList.add('swiped-right');
    const song = card.songData;
    likedSongs.push(song);
    updateStats(song, true);
    setTimeout(() => {
      card.remove();
      nextCard();
    }, 500);
  }
  
  
  function swipeLeft(card) {
    card.classList.add('swiped-left');
    const song = card.songData;
    updateStats(song, false);
    setTimeout(() => {
      card.remove();
      nextCard();
    }, 500);
  }
  
 
  function nextCard() {
    currentIndex++;
    totalSwiped++;
    totalSwipedEl.textContent = totalSwiped;
    
    if (currentIndex >= shuffled.length) {
      
      showEndMessage();
      return;
    }
    
    
    const nextIndex = currentIndex + 2;
    if (nextIndex < shuffled.length && swipeDeck.children.length < 3) {
      const nextCard = createCard(shuffled[nextIndex], nextIndex);
      swipeDeck.appendChild(nextCard);
      
      
      prewarmAudioForSong(shuffled[nextIndex]).catch(() => {});
    }
    
   
    if (currentIndex < shuffled.length) {
      prewarmAudioForSong(shuffled[currentIndex]).catch(() => {});
    }
    
    
    const topCard = swipeDeck.querySelector('.swipe-card:not(.swiped-left):not(.swiped-right)');
    if (topCard) {
      setupCardDrag(topCard);
    }
  }
  
  
  function updateStats(song, liked) {
    
    const genre = getSongGenre(song);
    if (liked) {
      swipedGenres[genre] = (swipedGenres[genre] || 0) + 1;
    }
    
    
    const mood = getSongMood(song);
    if (liked) {
      swipedMoods[mood]++;
    }
    
   
    if (liked) {
      ['danceability_%', 'energy_%', 'valence_%', 'acousticness_%'].forEach((feature, idx) => {
        const key = ['danceability', 'energy', 'valence', 'acousticness'][idx];
        const value = parseFloat(song[feature]) || 0;
        swipedFeatures[key].push(value);
      });
    }
    
    
    likedCountEl.textContent = likedSongs.length;
    updateLikedList();
    updateCharts();
    
    
    exportBtn.disabled = likedSongs.length === 0;
  }
  
  
  function updateLikedList() {
    if (likedSongs.length === 0) {
      likedListEl.innerHTML = '<div class="liked-item" style="text-align:center;color:var(--text-secondary);">Aucun titre aim√©</div>';
      return;
    }
    
    const last5 = likedSongs.slice(-5).reverse();
    likedListEl.innerHTML = last5.map(song => 
      `<div class="liked-item">‚ô• ${song.track_name} - ${song["artist(s)_name"]}</div>`
    ).join('');
  }
  
  
  function updateCharts() {
    updateGenrePieChart();
    updateMoodRadarChart();
  }
  
  
  function getGenreColors(count) {
    const hues = [140, 150, 160, 170, 180, 190]; 
    const colors = [];
    for (let i = 0; i < count; i++) {
      const h = hues[i % hues.length];
      const tier = Math.floor(i / hues.length);
      const sat = Math.max(45, 70 - tier * 10);   
      const light = Math.min(72, 38 + (i % hues.length) * 6); 
      colors.push(`hsl(${h} ${sat}% ${light}%)`);
    }
    return colors;
  }
  
  
  function updateGenrePieChart() {
    const ctx = document.getElementById('genre-pie-chart');
    if (!ctx) return;
    
    const genres = Object.keys(swipedGenres);
    const counts = Object.values(swipedGenres);
    
    if (genres.length === 0) {
      if (genrePieChart) genrePieChart.destroy();
      genrePieChart = null;
      return;
    }
  const bgColors = getGenreColors(genres.length);
  const isLight = document.body.classList.contains('light-mode');
  const borderCol = isLight ? '#e5e5e5' : (getComputedStyle(document.documentElement).getPropertyValue('--bg-primary') || '#121212');
  const legendLabelColor = isLight ? '#000' : getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
    
    if (genrePieChart) {
      genrePieChart.data.labels = genres;
      genrePieChart.data.datasets[0].data = counts;
      genrePieChart.data.datasets[0].backgroundColor = bgColors;
      genrePieChart.data.datasets[0].borderColor = borderCol;
      genrePieChart.data.datasets[0].borderWidth = 2;
      
      genrePieChart.options.plugins.legend.labels.color = legendLabelColor;
      genrePieChart.update();
    } else {
      genrePieChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: genres,
          datasets: [{
            data: counts,
            backgroundColor: bgColors,
            borderColor: borderCol,
            borderWidth: 2,
            hoverOffset: 8,
            spacing: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          cutout: '58%',
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                color: legendLabelColor,
                font: { size: 11 }
              }
            }
          }
        }
      });
    }
  }
  
  
  function updateMoodRadarChart() {
    const ctx = document.getElementById('mood-radar-chart');
    if (!ctx) return;
    
    const moodLabels = ['Joyeux', '√ânergique', 'Triste', 'Calme'];
    const moodData = [
      swipedMoods.joyeux,
      swipedMoods.energique,
      swipedMoods.triste,
      swipedMoods.calme
    ];
    
    const isLight = document.body.classList.contains('light-mode');
    const gridColor = isLight ? 'rgba(0,0,0,0.12)' : 'rgba(255,255,255,0.1)';
    const labelColor = isLight ? '#000' : getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
    const tickColor = isLight ? 'rgba(0,0,0,0.6)' : getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');

    if (moodRadarChart) {
      moodRadarChart.data.datasets[0].data = moodData;
      
      moodRadarChart.options.scales.r.grid.color = gridColor;
      moodRadarChart.options.scales.r.pointLabels.color = labelColor;
      moodRadarChart.options.scales.r.ticks.display = false;
      if (moodRadarChart.options.plugins && moodRadarChart.options.plugins.legend && moodRadarChart.options.plugins.legend.labels) {
        moodRadarChart.options.plugins.legend.labels.color = labelColor;
      }
      moodRadarChart.update();
    } else {
      moodRadarChart = new Chart(ctx, {
        type: 'radar',
        data: {
          labels: moodLabels,
          datasets: [{
            label: 'Pr√©f√©rences',
            data: moodData,
            backgroundColor: 'rgba(29, 185, 84, 0.2)',
            borderColor: '#1db954',
            borderWidth: 2,
            pointBackgroundColor: '#1db954',
            pointBorderColor: '#fff',
            pointRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            r: {
              beginAtZero: true,
              ticks: {
                display: false,
                stepSize: 1
              },
              grid: {
                color: gridColor
              },
              pointLabels: {
                color: labelColor,
                font: { size: 12 }
              }
            }
          },
          plugins: {
            legend: { display: false }
          }
        }
      });
    }
  }
  
  
  function showEndMessage() {
    swipeDeck.style.display = 'none';
    document.querySelector('.swipe-buttons').style.display = 'none';
    swipeEndMessage.style.display = 'block';
  }
  
  
  function resetSwipe() {
    currentIndex = 0;
    likedSongs = [];
    totalSwiped = 0;
    swipedGenres = {};
    swipedMoods = { joyeux: 0, triste: 0, energique: 0, calme: 0 };
    swipedFeatures = { danceability: [], energy: [], valence: [], acousticness: [] };
    
    likedCountEl.textContent = '0';
    totalSwipedEl.textContent = '0';
    updateLikedList();
    
    if (genrePieChart) {
      genrePieChart.destroy();
      genrePieChart = null;
    }
    if (moodRadarChart) {
      moodRadarChart.destroy();
      moodRadarChart = null;
    }
    
    swipeDeck.style.display = 'block';
    document.querySelector('.swipe-buttons').style.display = 'flex';
    swipeEndMessage.style.display = 'none';
    exportBtn.disabled = true;
    
    initCards();
  }
  
  
  function exportPlaylist() {
    if (likedSongs.length === 0) return;
    
    const playlistText = likedSongs.map((song, i) => 
      `${i + 1}. ${song.track_name} - ${song["artist(s)_name"]}`
    ).join('\n');
    
    const blob = new Blob([playlistText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ma-playlist-spotify.txt';
    a.click();
    URL.revokeObjectURL(url);
    
    
    navigator.clipboard.writeText(playlistText).then(() => {
      const originalText = exportBtn.textContent;
      exportBtn.textContent = '‚úì Copi√© !';
      setTimeout(() => {
        exportBtn.textContent = originalText;
      }, 2000);
    }).catch(() => {
      alert('Playlist t√©l√©charg√©e !');
    });
  }
  
  
  likeBtn.addEventListener('click', () => {
    const topCard = swipeDeck.querySelector('.swipe-card:not(.swiped-left):not(.swiped-right)');
    if (topCard) swipeRight(topCard);
  });
  
  dislikeBtn.addEventListener('click', () => {
    const topCard = swipeDeck.querySelector('.swipe-card:not(.swiped-left):not(.swiped-right)');
    if (topCard) swipeLeft(topCard);
  });
  
  resetBtn.addEventListener('click', resetSwipe);
  exportBtn.addEventListener('click', exportPlaylist);
  
  
  document.addEventListener('keydown', (e) => {
    const swipeSection = document.getElementById('swipe-playlist');
    if (!swipeSection) return;
    
    const rect = swipeSection.getBoundingClientRect();
    const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
    if (!isVisible) return;
    
    const topCard = swipeDeck.querySelector('.swipe-card:not(.swiped-left):not(.swiped-right)');
    if (!topCard) return;
    
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
      e.preventDefault();
      swipeRight(topCard);
    } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
      e.preventDefault();
      swipeLeft(topCard);
    }
  });
  
  
  let hoverAudio = null;
  let hoverLoadingToken = 0;
  
  async function loadSwipeAudio(song, forcePlay=false) {
    if (!song) return;
    if (hoverAudio) { 
      hoverAudio.pause(); 
      hoverAudio.currentTime = 0; 
      hoverAudio = null; 
    }
    const myToken = ++hoverLoadingToken;
    
    
    let audio = getCachedAudioForSong(song);
    if (!audio) {
      
      audio = await prewarmAudioForSong(song);
      if (!audio) return;
    }
    
    
    audio.currentTime = 0;
    audio.volume = 0.4;
    
    try {
      const playPromise = audio.play();
      if (playPromise) await playPromise;
      if (myToken === hoverLoadingToken) { 
        hoverAudio = audio; 
      } else { 
        audio.pause(); 
        audio.currentTime = 0; 
      }
    } catch(e) { 
      
    }
  }
  
  
  const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
  
  function setupCardAudio(card) {
    if (!card || !card.songData) return;
    
    if (!isTouch) {
      
      card.addEventListener('mouseenter', () => {
        loadSwipeAudio(card.songData);
      });
      card.addEventListener('mouseleave', () => {
        hoverLoadingToken++;
        if (hoverAudio) { 
          hoverAudio.pause(); 
          hoverAudio = null; 
        }
      });
    } else {
     
      const cardImage = card.querySelector('.swipe-card-image');
      if (cardImage) {
        cardImage.addEventListener('touchstart', (e) => {
          e.stopPropagation(); 
          const song = card.songData;
          if (!song) return;
          if (hoverAudio) { 
            hoverAudio.pause(); 
            hoverAudio = null; 
            return; 
          }
          loadSwipeAudio(song, true);
        }, { passive: false });
      }
    }
  }
  
 
  const originalInitCards = initCards;
  initCards = function() {
    originalInitCards();
    
    const cards = swipeDeck.querySelectorAll('.swipe-card');
    cards.forEach(setupCardAudio);
  };
  
  
  const originalNextCard = nextCard;
  nextCard = function() {
    originalNextCard();
   
    const topCard = swipeDeck.querySelector('.swipe-card:not(.swiped-left):not(.swiped-right)');
    if (topCard) {
      setupCardAudio(topCard);
    }
  };
  
  
  initCards();
  updateLikedList();
}


function renderRadar(data){
  
  const parseStreams = v => Number(String(v).replace(/,/g,''))||0;
  const sorted = [...data].sort((a,b)=>parseStreams(b.streams)-parseStreams(a.streams));
  const shortlist = sorted.slice(0, 80); 

  const select = document.getElementById('radar-select');
  const ctx = document.getElementById('radarChart').getContext('2d');

  
  select.innerHTML = '';
  shortlist.forEach((s, idx)=>{
    const opt = document.createElement('option');
    opt.value = String(idx);
    opt.textContent = `${s.track_name} ‚Äî ${s["artist(s)_name"]}`;
    select.appendChild(opt);
  });

  const features = [
    { key: 'danceability_%', label: 'Dansabilit√©' },
    { key: 'valence_%', label: 'Valence' },
    { key: 'energy_%', label: '√ânergie' },
    { key: 'acousticness_%', label: 'Acoustique' },
    { key: 'instrumentalness_%', label: 'Instrumental' },
    { key: 'liveness_%', label: 'Vivacit√©' },
    { key: 'speechiness_%', label: 'Parl√©' },
  ];

  const toVals = (row)=> features.map(f=>{
    const n = Number(row[f.key]);
    return isNaN(n) ? 0 : Math.max(0, Math.min(100, n));
  });

  
  if (window._radar) { try { window._radar.destroy(); } catch(e){} }
  const first = shortlist[0] || data[0];
  
  
  const isDark = document.body.classList.contains('dark-mode');
  const gridColor = isDark ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.12)';
  const angleColor = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.08)';
  const labelColor = isDark ? '#cfe7d8' : '#2d3e34';
  const tickColor = isDark ? '#88a598' : '#4a6156';
  
  const chart = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: features.map(f=>f.label),
      datasets: [{
        label: `${first.track_name} ‚Äî ${first["artist(s)_name"]}`,
        data: toVals(first),
        borderColor: 'rgba(29,185,84,1)',
        backgroundColor: 'rgba(29,185,84,0.18)',
        pointBackgroundColor: '#1db954',
        pointRadius: 3,
        pointHoverRadius: 5,
        borderWidth: 2
      }]
    },
    options: {
      responsive: true,
      scales: {
        r: {
          angleLines: { color: angleColor },
          grid: { color: gridColor },
          suggestedMin: 0, suggestedMax: 100,
          pointLabels: { color: labelColor, font: { size: 12 } },
          ticks: { showLabelBackdrop: false, color: tickColor, backdropColor: 'transparent', stepSize: 20 }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: (ctx)=> `${ctx.label} : ${ctx.formattedValue} %`
          }
        }
      }
    }
  });
  window._radar = chart;

  select.addEventListener('change', (e)=>{
    const idx = Number(e.target.value);
    const row = shortlist[idx] || first;
    chart.data.datasets[0].label = `${row.track_name} ‚Äî ${row["artist(s)_name"]}`;
    chart.data.datasets[0].data = toVals(row);
    chart.update();
  });
}




function renderSongs(data){
  const container=document.getElementById("songs-container");
  container.innerHTML="";
  data.slice(0,50).forEach((song,index)=>{
    const card=document.createElement("div");
    card.className="song-card";
    card.innerHTML=`
      <img src="${song.cover_url}" alt="cover">
      <div class="song-info">
        <div class="title">${song.track_name}</div>
        <div class="artist">${song["artist(s)_name"]}</div>
        <div class="streams">${Number(String(song.streams).replace(/,/g,'')).toLocaleString()} streams</div>
      </div>`;
    container.appendChild(card);
    setTimeout(()=>card.classList.add("visible"), index*50);
  });
  setupCardClick();
}




function renderGenre3D(data) {
    
    const genreStats = {};
    data.forEach(item => {
        const artists = item["artist(s)_name"]?.split(",") || [];
        let genre = "Autre";
        for (const artist of artists) {
            const cleanArtist = artist.trim();
            if (genreByArtist[cleanArtist]) {
                genre = genreByArtist[cleanArtist];
                break;
            }
        }
        const streams = Number(String(item.streams).replace(/,/g,'')) || 0;
        genreStats[genre] = (genreStats[genre] || 0) + streams;
    });

    
    const container = document.getElementById('genre3DCanvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a); 
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ 
        canvas: container,
        antialias: true,
        alpha: true
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0x1db954, 2);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1;

    
    let isMouseOverCanvas = false;

    
    container.addEventListener('mouseenter', () => {
        isMouseOverCanvas = true;
        controls.enableZoom = true;
    });

    container.addEventListener('mouseleave', () => {
        isMouseOverCanvas = false;
        controls.enableZoom = false;
    });

    
    document.addEventListener('wheel', (event) => {
        const rect = container.getBoundingClientRect();
        const mouseX = event.clientX;
        const mouseY = event.clientY;
        const isInBounds = mouseX >= rect.left && 
                          mouseX <= rect.right && 
                          mouseY >= rect.top && 
                          mouseY <= rect.bottom;

        if (isInBounds) {
            event.preventDefault();
            if (controls.enableZoom) {
                
                const delta = event.deltaY;
                controls.zoomSpeed = 0.5; 
                if (delta > 0) {
                    controls.dollyOut(1.1);
                } else {
                    controls.dollyIn(1.1);
                }
            }
        }
        
    }, { passive: false });

    
    controls.mouseButtons.MIDDLE = null;
    controls.touches.TWO = null;
    
    
    camera.position.set(0, 2.2, 2.2); 
    camera.lookAt(0, 0, 0); 
    
    
    controls.minPolarAngle = Math.PI / 4; 
    controls.maxPolarAngle = Math.PI / 1.5; 
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.5; 
    controls.minDistance = 1.8; 
    controls.maxDistance = 5; 

    
    const totalValue = Object.values(genreStats).reduce((a, b) => a + b, 0);
    let startAngle = 0;
    const segments = [];
    const radius = 1.2; 
    const height = 0.2; 
    const colors = [
        0x1db954, 0x1ed760, 0x0aff9d, 
        0x00ff88, 0x00e676, 0x00c853
    ];

    Object.entries(genreStats).forEach(([genre, value], index) => {
        const percentage = value / totalValue;
        const angle = percentage * Math.PI * 2;
        
        const geometry = new THREE.CylinderGeometry(
            radius, radius + 0.1,
            height, 32, 1,
            false, startAngle, angle
        );

        const material = new THREE.MeshPhongMaterial({
            color: colors[index % colors.length],
            transparent: true,
            opacity: 0.8,
            shininess: 100
        });

        const segment = new THREE.Mesh(geometry, material);
        segment.userData = { genre, streams: value, percentage };
        
        
        gsap.to(segment.position, {
            y: 0.1,
            duration: 1.5 + Math.random(),
            yoyo: true,
            repeat: -1,
            ease: "sine.inOut"
        });

        scene.add(segment);
        segments.push(segment);
        startAngle += angle;
    });

    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const tooltip = document.querySelector('.genre-tooltip');
    const genreDetails = document.querySelector('.genre-details');

    container.addEventListener('mousemove', (event) => {
        const rect = container.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(segments);

        if (intersects.length > 0) {
            const segment = intersects[0].object;
            const { genre, streams, percentage } = segment.userData;
            
            tooltip.style.opacity = '1';
            tooltip.style.transform = 'translateY(0)';
            tooltip.style.left = event.clientX + 'px';
            tooltip.style.top = event.clientY + 'px';
      tooltip.innerHTML = `
        ${genre}<br>
        ${Number(streams).toLocaleString()} √©coutes<br>
        ${(percentage * 100).toFixed(1)}%
      `;

            
            gsap.to(segment.scale, {
                x: 1.1,
                y: 1.1,
                z: 1.1,
                duration: 0.3
            });

            document.body.style.cursor = 'pointer';
        } else {
            tooltip.style.opacity = '0';
            tooltip.style.transform = 'translateY(10px)';
            segments.forEach(seg => {
                gsap.to(seg.scale, {
                    x: 1,
                    y: 1,
                    z: 1,
                    duration: 0.3
                });
            });
            document.body.style.cursor = 'default';
        }
    });

   
  let _rafId = null; let _paused = false;
  function animate() {
    if (_paused) return;
    _rafId = requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

   
  const _onResizeGenre = () => {
    const width = container.clientWidth;
    const height = container.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  };
  window.addEventListener('resize', _onResizeGenre);


  const particlesGeometry = new THREE.BufferGeometry();
  const particlesCount = 600;
  const posArray = new Float32Array(particlesCount * 3);

  for(let i = 0; i < particlesCount; i++) {
    const r = 3.5 + Math.random() * 6.5;
    const a = Math.random() * Math.PI * 2;
    posArray[i*3+0] = Math.cos(a) * r * (0.6 + Math.random()*0.8);
    posArray[i*3+1] = (Math.random() - 0.5) * 1.6;
    posArray[i*3+2] = Math.sin(a) * r * (0.6 + Math.random()*0.8);
  }

  particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  const particlesMaterial = new THREE.PointsMaterial({
    size: 0.02,
    color: 0x1db954,
    transparent: true,
    opacity: 0.22,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
  scene.add(particlesMesh);

  
  gsap.to(particlesMesh.rotation, {
    y: Math.PI * 2,
    duration: 36,
    repeat: -1,
    ease: "none"
  });

  
  window._genre3d = {
    pause(){ try{ cancelAnimationFrame(_rafId);}catch(e){}; _paused = true; },
    resume(){ if(!_paused) return; _paused=false; try{ requestAnimationFrame(()=>{ animate(); }); }catch(e){} },
    dispose(){ try{ cancelAnimationFrame(_rafId);}catch(e){}; try{ renderer.dispose(); controls.dispose(); }catch(e){}; try{ window.removeEventListener('resize', _onResizeGenre);}catch(e){} }
  };
}

function setupSearch(data){
  const input=document.getElementById("search");
  input.addEventListener("input",()=>{
    const q=input.value.toLowerCase();
    const filtered=data.filter(s=>(s.track_name&&s.track_name.toLowerCase().includes(q))||(s["artist(s)_name"]&&s["artist(s)_name"].toLowerCase().includes(q)));
    renderSongs(filtered);
  });
}

function setupCardClick(){
  const songModal = document.getElementById("song-modal");
  const modalTitle = document.getElementById("modal-title");
  const modalArtist = document.getElementById("modal-artist");
  const modalStreams = document.getElementById("modal-streams");
  const modalCover = document.getElementById("modal-cover");

  document.querySelectorAll(".song-card").forEach(card=>{
    card.addEventListener("click",()=>{
      modalTitle.innerText = card.querySelector(".title").innerText;
      modalArtist.innerText = card.querySelector(".artist").innerText;
      modalStreams.innerText = card.querySelector(".streams").innerText;
      modalCover.src = card.querySelector("img").src;
      
      songModal.style.display = "flex";
      document.body.style.overflow = "hidden";
    });
  });

 
  const closeBtn = document.getElementById("close-modal");
  if (closeBtn) {
    closeBtn.addEventListener("click", () => {
      songModal.style.display = "none";
      document.body.style.overflow = "";
    });
  }

  
  songModal.addEventListener('click', (e) => {
    if (e.target === songModal) {
      songModal.style.display = 'none';
      document.body.style.overflow = "";
    }
  });
}


function initAudioPlayer(data) {
  const player = document.getElementById('audio-player');
  const playBtn = document.getElementById('play-btn');
  
  const progressBar = document.getElementById('progress-bar');
  const progressFill = document.getElementById('progress-fill');
  const timeDisplay = document.getElementById('time-display');
  const volumeSlider = document.getElementById('volume-slider');
  const playerTitle = document.getElementById('player-title');
  const playerArtist = document.getElementById('player-artist');
  const playerCover = document.getElementById('player-cover');

  let currentTrack = null;
  let audioElement = null;
  let audioContext = null; 
  let isPlaying = false;
  let progressInterval = null;
  const previewCache = new Map();
  
  let activeAudios = [];
  
  let loadToken = 0;
  
  let autoplayPending = false;

  
  function sanitize(str) {
    return String(str || '')
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '') 
      .replace(/&/g, 'and')
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  function deriveAudioCandidates(track) {
    const t = sanitize(track.track_name);
    const a = sanitize(track['artist(s)_name'] || track.artist || '');
    const base = 'audio/';
    const names = [];
    if (a && t) {
      names.push(`${a}-${t}.mp3`);
      names.push(`${t}-${a}.mp3`);
    }
    if (t) names.push(`${t}.mp3`);
    if (a) names.push(`${a}.mp3`);
   
    const seen = new Set();
    return names.filter(n => (seen.has(n) ? false : (seen.add(n), true))).map(n => base + n);
  }

  function tryLoadAudio(candidates, onSuccess, onFail) {
    if (!candidates || !candidates.length) { onFail && onFail(); return; }
    const url = candidates[0];
    const audio = new Audio(url);
    audio.preload = 'metadata';
    audio.addEventListener('loadedmetadata', () => onSuccess && onSuccess(audio, url));
    audio.addEventListener('error', () => tryLoadAudio(candidates.slice(1), onSuccess, onFail));
    
    audio.load();
  }

  async function fetchITunesPreview(track) {
    const key = `${track['artist(s)_name'] || ''}|${track.track_name || ''}`;
    if (previewCache.has(key)) return previewCache.get(key);
    try {
      const term = `${track['artist(s)_name'] || ''} ${track.track_name || ''}`.trim();
      if (!term) return null;
      const url = `https://itunes.apple.com/search?term=${encodeURIComponent(term)}&media=music&entity=song&limit=1&country=FR`;
      const res = await fetch(url);
      if (!res.ok) return null;
      const json = await res.json();
      const preview = json && json.results && json.results[0] && json.results[0].previewUrl ? json.results[0].previewUrl : null;
      previewCache.set(key, preview || null);
      return preview;
    } catch (e) {
      return null;
    }
  }

  

  function updateProgress() {
    if (!audioElement || !currentTrack) return;
    const percent = (audioElement.currentTime / audioElement.duration) * 100;
    progressFill.style.width = percent + '%';
    const current = formatTime(audioElement.currentTime);
    const total = formatTime(audioElement.duration || 30);
    timeDisplay.textContent = `${current} / ${total}`;
  }

  function formatTime(sec) {
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return `${m}:${s.toString().padStart(2, '0')}`;
  }

  function loadTrack(track, autoplay = false) {
    stop();
    currentTrack = track;
    playerTitle.textContent = track.track_name;
    playerArtist.textContent = track['artist(s)_name'];
    playerCover.src = track.cover_url;
    player.classList.add('visible');
    
    
    const backToTop = document.getElementById('back-to-top');
    if (backToTop) backToTop.classList.add('player-visible');

    const manualUrl = track.audio && typeof track.audio === 'string' ? track.audio : null;
    const candidates = manualUrl ? [manualUrl] : deriveAudioCandidates(track);
    
    const myToken = ++loadToken;
    
    
    if (autoplay) {
      autoplayPending = true;
    }

    tryLoadAudio(candidates,
      (audio, url) => {
       
        if (myToken !== loadToken) {
          try { audio.pause(); } catch(e){}
          return;
        }
        audioElement = audio;
        currentTrack.audio = url; 
        audioElement.volume = volumeSlider.value / 100;
  
        timeDisplay.textContent = `0:00 / ${formatTime(audioElement.duration)}`;
        audioElement.addEventListener('ended', stop);
        audioElement.addEventListener('timeupdate', updateProgress);
        activeAudios.push(audioElement);
        if (autoplayPending) { autoplayPending = false; play(); }
      },
      () => {
       
        fetchITunesPreview(track).then(previewUrl => {
          if (myToken !== loadToken) return; 
          if (previewUrl) {
            const audio = new Audio(previewUrl);
            audio.preload = 'metadata';
            audio.addEventListener('loadedmetadata', () => {
              if (myToken !== loadToken) { try { audio.pause(); } catch(e){} return; }
              audioElement = audio;
              currentTrack.audio = previewUrl;
              audioElement.volume = volumeSlider.value / 100;
              
              timeDisplay.textContent = `0:00 / ${formatTime(audioElement.duration)}`;
              audioElement.addEventListener('ended', stop);
              audioElement.addEventListener('timeupdate', updateProgress);
              activeAudios.push(audioElement);
              if (autoplayPending) { autoplayPending = false; play(); }
            });
            audio.addEventListener('error', () => {
              audioElement = null;
              timeDisplay.textContent = 'Aucun audio';
              if (autoplayPending) { autoplayPending = false; play(); }
            });
            audio.load();
          } else {
            
            audioElement = null;
            timeDisplay.textContent = 'Aucun audio';
            if (autoplayPending) { autoplayPending = false; play(); }
          }
        }).catch(() => {
          audioElement = null;
          timeDisplay.textContent = 'Aucun audio';
          if (autoplayPending) { autoplayPending = false; play(); }
        });
      }
    );
  }

  function play() {
    if (!currentTrack) return;
  
    
    if (!audioElement) {
      return;
    } else {
    
      audioElement.play();
      isPlaying = true;
      playBtn.textContent = '‚è∏';
      playBtn.classList.add('active');
    }
  }

  function pause() {
    if (audioElement) {
      audioElement.pause();
    }
    isPlaying = false;
    playBtn.textContent = '‚ñ∂';
    playBtn.classList.remove('active');
  }

  function stop() {
    pause();
    if (progressInterval) clearInterval(progressInterval);
    progressFill.style.width = '0%';
    
    
    if (audioElement) {
      try {
        audioElement.pause();
        audioElement.currentTime = 0;
        audioElement.removeEventListener('ended', stop);
        audioElement.removeEventListener('timeupdate', updateProgress);
      } catch(e){}
    }
    
    
    activeAudios.forEach(a => { 
      try { 
        a.pause(); 
        a.currentTime = 0;
        a.removeEventListener('ended', stop);
        a.removeEventListener('timeupdate', updateProgress);
      } catch(e){} 
    });
    activeAudios = [];
    audioElement = null;
    autoplayPending = false;
  }

  
  playBtn.addEventListener('click', () => {
    if (!currentTrack) return;
    if (isPlaying) pause();
    else play();
  });

 

  progressBar.addEventListener('click', (e) => {
    if (!audioElement) return;
    const rect = progressBar.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;
    audioElement.currentTime = percent * audioElement.duration;
  });

  volumeSlider.addEventListener('input', (e) => {
    if (audioElement) audioElement.volume = e.target.value / 100;
  });

 
  window.loadPlayerTrack = loadTrack;
  window.stopPlayerTrack = stop;
  window.playPlayerTrack = () => {
    if (!currentTrack) return;
    if (audioElement && !isPlaying) play();
  };

  const audioPlayer = document.getElementById('audio-player');
  const closePlayerBtn = document.getElementById('close-player');
  if (closePlayerBtn) {
    closePlayerBtn.addEventListener('click', () => {
      audioPlayer.classList.remove('visible');
      
      const backToTop = document.getElementById('back-to-top');
      if (backToTop) backToTop.classList.remove('player-visible');
      if (window.stop) window.stop();
    });
  }
}

</script>

</div>

<script>
  
  const themeToggle = document.getElementById('theme-toggle');
  const body = document.body;
  
  
  const moonIcon = '<svg viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>';
  const sunIcon = '<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>';
  
  
  const savedTheme = localStorage.getItem('theme') || 'dark';
  if (savedTheme === 'light') {
    body.classList.add('light-mode');
    body.classList.remove('dark-mode');
    themeToggle.innerHTML = moonIcon + '<span>Sombre</span>';
  } else {
    body.classList.add('dark-mode');
  }
  
  themeToggle.addEventListener('click', () => {
    body.classList.toggle('light-mode');
    const isLight = body.classList.contains('light-mode');
    themeToggle.innerHTML = isLight ? moonIcon + '<span>Sombre</span>' : sunIcon + '<span>Clair</span>';
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
    
    
    if (window._radar) {
      const isDark = !isLight;
      const gridColor = isDark ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.12)';
      const angleColor = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.08)';
      const labelColor = isDark ? '#cfe7d8' : '#2d3e34';
      const tickColor = isDark ? '#88a598' : '#4a6156';
      
      window._radar.options.scales.r.angleLines.color = angleColor;
      window._radar.options.scales.r.grid.color = gridColor;
      window._radar.options.scales.r.pointLabels.color = labelColor;
      window._radar.options.scales.r.ticks.color = tickColor;
      window._radar.update();
    }

    
    if (typeof updateGenrePieChart === 'function') {
      updateGenrePieChart();
    }
    if (typeof updateMoodRadarChart === 'function') {
      updateMoodRadarChart();
    }
  });

 
  const burgerMenu = document.getElementById('burger-menu');
  const mobileMenu = document.getElementById('mobile-menu');
  
  burgerMenu.addEventListener('click', () => {
    burgerMenu.classList.toggle('active');
    mobileMenu.classList.toggle('active');
   
    body.style.overflow = mobileMenu.classList.contains('active') ? 'hidden' : '';
  });
  
  
  document.querySelectorAll('#mobile-menu a').forEach(link => {
    link.addEventListener('click', () => {
      burgerMenu.classList.remove('active');
      mobileMenu.classList.remove('active');
      body.style.overflow = '';
    });
  });
  
 
  const mobileLinks = document.querySelectorAll('#mobile-menu a');
  const desktopLinks = document.querySelectorAll('#main-nav .nav-links a');
  
  function updateActiveLink() {
    const scrollPos = window.scrollY + 100;
    
    
    const sections = Array.from(document.querySelectorAll('[id]')).filter(el => {
      const id = el.getAttribute('id');
  return id && (id === 'radial' || id === 'radar' || id === 'top-artists' || 
        id === 'mood' || id === 'higher-or-lower' || id === 'timeline' || 
                    id === 'genres' || id === 'search-section');
    });
    
    let currentSection = '';
    sections.forEach(section => {
      const sectionTop = section.offsetTop;
      if (scrollPos >= sectionTop - 200) {
        currentSection = section.getAttribute('id');
      }
    });
    
   
    [...mobileLinks, ...desktopLinks].forEach(link => {
      link.classList.remove('active');
      if (link.getAttribute('href') === `#${currentSection}`) {
        link.classList.add('active');
      }
    });
  }
  
  window.addEventListener('scroll', updateActiveLink);
  updateActiveLink(); 

  
  const observerOptions = {
    threshold: 0.1,
    rootMargin: '0px 0px -50px 0px'
  };
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('animate-in');
        observer.unobserve(entry.target);
      }
    });
  }, observerOptions);
  
  
  document.querySelectorAll('.animate-on-scroll').forEach(section => {
    observer.observe(section);
  });

  
  const backToTop = document.getElementById('back-to-top');
  window.addEventListener('scroll', () => {
    if (window.scrollY > 300) {
      backToTop.classList.add('visible');
    } else {
      backToTop.classList.remove('visible');
    }
  });
  backToTop.addEventListener('click', () => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  });

  
  const sections = document.querySelectorAll('[id]');
  const navLinks = document.querySelectorAll('#main-nav a[href^="#"]');
  window.addEventListener('scroll', () => {
    let current = '';
    sections.forEach(section => {
      const sectionTop = section.offsetTop - 80;
      if (window.scrollY >= sectionTop) {
        current = section.getAttribute('id');
      }
    });
    navLinks.forEach(link => {
      link.classList.remove('active');
      if (link.getAttribute('href') === `#${current}`) {
        link.classList.add('active');
      }
    });
  });
</script>

</body>
</html>
